// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { APIResource } from "../../resource.mjs";
import { isRequestOptions } from "../../core.mjs";
import { poll } from '@runloop/api-client/lib/polling';
export class Executions extends APIResource {
    retrieve(devboxId, executionId, query = {}, options) {
        if (isRequestOptions(query)) {
            return this.retrieve(devboxId, executionId, {}, query);
        }
        return this._client.get(`/v1/devboxes/${devboxId}/executions/${executionId}`, { query, ...options });
    }
    /**
     * Execute the given command in the Devbox shell asynchronously and returns the
     * execution that can be used to track the command's progress.
     */
    executeAsync(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/execute_async`, { body, ...options });
    }
    /**
     * Wait for an async execution to complete.
     * Polls the execution status until it reaches completed state.
     */
    async awaitCompleted(id, executionId, options) {
        const finalResult = await poll(() => this.retrieve(id, executionId, options), () => this.retrieve(id, executionId, options), {
            ...options?.polling,
            shouldStop: (result) => {
                return result.status === 'completed';
            },
        });
        return finalResult;
    }
    /**
     * Execute a bash command in the Devbox shell, await the command completion and
     * return the output.
     */
    executeSync(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/execute_sync`, { body, ...options });
    }
    /**
     * Kill a previously launched asynchronous execution if it is still running by
     * killing the launched process.
     */
    kill(devboxId, executionId, options) {
        return this._client.post(`/v1/devboxes/${devboxId}/executions/${executionId}/kill`, options);
    }
}
//# sourceMappingURL=executions.mjs.map