// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { APIResource } from "../../resource.mjs";
import { isRequestOptions } from "../../core.mjs";
import * as Core from "../../core.mjs";
import * as ExecutionsAPI from "./executions.mjs";
import { Executions, } from "./executions.mjs";
import * as LogsAPI from "./logs.mjs";
import { Logs } from "./logs.mjs";
import * as LspAPI from "./lsp.mjs";
import { Lsp, } from "./lsp.mjs";
import { DevboxesCursorIDPage, DiskSnapshotsCursorIDPage, } from "../../pagination.mjs";
import { poll } from '@runloop/api-client/lib/polling';
import { RunloopError } from "../../index.mjs";
import { DevboxTools } from "./tools.mjs";
const DEVBOX_BOOTING_STATES = ['provisioning', 'initializing'];
export class Devboxes extends APIResource {
    constructor() {
        super(...arguments);
        this.lsp = new LspAPI.Lsp(this._client);
        this.logs = new LogsAPI.Logs(this._client);
        this.executions = new ExecutionsAPI.Executions(this._client);
    }
    create(body = {}, options) {
        if (isRequestOptions(body)) {
            return this.create({}, body);
        }
        return this._client.post('/v1/devboxes', { body, ...options });
    }
    /**
     * Get the latest details and status of a Devbox.
     */
    retrieve(id, options) {
        return this._client.get(`/v1/devboxes/${id}`, options);
    }
    /**
     * Wait for a devbox to reach the running state.
     * Polls the devbox status until it reaches running state or fails with an error.
     */
    async awaitRunning(id, options) {
        const finalResult = await poll(() => this.retrieve(id, options), () => this.retrieve(id, options), {
            ...options?.polling,
            shouldStop: (result) => {
                return !DEVBOX_BOOTING_STATES.includes(result.status);
            },
        });
        // Now we check if the devbox is 'running' otherwise we throw an error
        if (finalResult.status !== 'running') {
            throw new RunloopError(`Devbox ${id} is in non-running state ${finalResult.status}`);
        }
        return finalResult;
    }
    /**
     * Create a devbox and wait for it to reach the running state.
     * This is a convenience method that combines create() and awaitDevboxRunning().
     */
    async createAndAwaitRunning(body, options) {
        const devbox = await this.create(body, options);
        return this.awaitRunning(devbox.id, options);
    }
    list(query = {}, options) {
        if (isRequestOptions(query)) {
            return this.list({}, query);
        }
        return this._client.getAPIList('/v1/devboxes', DevboxViewsDevboxesCursorIDPage, { query, ...options });
    }
    /**
     * Create an SSH key for a Devbox to enable remote access.
     */
    createSSHKey(id, options) {
        return this._client.post(`/v1/devboxes/${id}/create_ssh_key`, options);
    }
    /**
     * Create a live tunnel to an available port on the Devbox. Note the port must be
     * made available using Devbox.create.availablePorts. Otherwise, the tunnel will
     * not connect to any running processes on the Devbox.
     */
    createTunnel(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/create_tunnel`, { body, ...options });
    }
    /**
     * Delete a previously taken disk snapshot of a Devbox.
     */
    deleteDiskSnapshot(id, options) {
        return this._client.post(`/v1/devboxes/disk_snapshots/${id}/delete`, options);
    }
    /**
     * Download file contents of any type (binary, text, etc) from a specified path on
     * the Devbox.
     */
    downloadFile(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/download_file`, {
            body,
            ...options,
            headers: { Accept: 'application/octet-stream', ...options?.headers },
            __binaryResponse: true,
        });
    }
    /**
     * Execute the given command in the Devbox shell asynchronously and returns the
     * execution that can be used to track the command's progress.
     */
    executeAsync(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/execute_async`, { body, ...options });
    }
    /**
     * Execute a bash command in the Devbox shell, await the command completion and
     * return the output.
     */
    executeSync(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/execute_sync`, { body, ...options });
    }
    /**
     * Send a 'Keep Alive' signal to a running Devbox that is configured to shutdown on
     * idle so the idle time resets.
     */
    keepAlive(id, options) {
        return this._client.post(`/v1/devboxes/${id}/keep_alive`, options);
    }
    listDiskSnapshots(query = {}, options) {
        if (isRequestOptions(query)) {
            return this.listDiskSnapshots({}, query);
        }
        return this._client.getAPIList('/v1/devboxes/disk_snapshots', DevboxSnapshotViewsDiskSnapshotsCursorIDPage, { query, ...options });
    }
    /**
     * Read file contents from a file on a Devbox as a UTF-8. Note 'downloadFile'
     * should be used for large files (greater than 100MB). Returns the file contents
     * as a UTF-8 string.
     */
    readFileContents(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/read_file_contents`, {
            body,
            ...options,
            headers: { Accept: 'text/plain', ...options?.headers },
        });
    }
    /**
     * Remove a previously opened tunnel on the Devbox.
     */
    removeTunnel(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/remove_tunnel`, { body, ...options });
    }
    /**
     * Resume a suspended Devbox with the disk state captured as suspend time. Note
     * that any previously running processes or daemons will need to be restarted using
     * the Devbox shell tools.
     */
    resume(id, options) {
        return this._client.post(`/v1/devboxes/${id}/resume`, options);
    }
    /**
     * Shutdown a running Devbox. This will permanently stop the Devbox. If you want to
     * save the state of the Devbox, you should take a snapshot before shutting down or
     * should suspend the Devbox instead of shutting down.
     */
    shutdown(id, options) {
        return this._client.post(`/v1/devboxes/${id}/shutdown`, options);
    }
    snapshotDisk(id, body = {}, options) {
        if (isRequestOptions(body)) {
            return this.snapshotDisk(id, {}, body);
        }
        return this._client.post(`/v1/devboxes/${id}/snapshot_disk`, { body, ...options });
    }
    /**
     * Suspend a running Devbox and create a disk snapshot to enable resuming the
     * Devbox later with the same disk. Note this will not snapshot memory state such
     * as running processes.
     */
    suspend(id, options) {
        return this._client.post(`/v1/devboxes/${id}/suspend`, options);
    }
    /**
     * Upload file contents of any type (binary, text, etc) to a Devbox. Note this API
     * is suitable for large files (larger than 100MB) and efficiently uploads files
     * via multipart form data.
     */
    uploadFile(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/upload_file`, Core.multipartFormRequestOptions({ body, ...options }));
    }
    /**
     * Write UTF-8 string contents to a file at path on the Devbox. Note for large
     * files (larger than 100MB), the upload_file endpoint must be used.
     */
    writeFileContents(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/write_file_contents`, { body, ...options });
    }
    // Make an accessor for tools
    get tools() {
        return new DevboxTools(this);
    }
}
export class DevboxViewsDevboxesCursorIDPage extends DevboxesCursorIDPage {
}
export class DevboxSnapshotViewsDiskSnapshotsCursorIDPage extends DiskSnapshotsCursorIDPage {
}
Devboxes.DevboxViewsDevboxesCursorIDPage = DevboxViewsDevboxesCursorIDPage;
Devboxes.DevboxSnapshotViewsDiskSnapshotsCursorIDPage = DevboxSnapshotViewsDiskSnapshotsCursorIDPage;
Devboxes.Lsp = Lsp;
Devboxes.Logs = Logs;
Devboxes.Executions = Executions;
//# sourceMappingURL=devboxes.mjs.map