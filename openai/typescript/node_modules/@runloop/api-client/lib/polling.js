"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.poll = exports.MaxAttemptsExceededError = exports.PollingTimeoutError = void 0;
const DEFAULT_OPTIONS = {
    initialDelayMs: 1000,
    pollingIntervalMs: 1000,
    maxAttempts: 120,
};
class PollingTimeoutError extends Error {
    constructor(message, lastResult) {
        super(`${message}. Last result: ${JSON.stringify(lastResult, null, 2)}`);
        this.lastResult = lastResult;
        this.name = 'PollingTimeoutError';
    }
}
exports.PollingTimeoutError = PollingTimeoutError;
class MaxAttemptsExceededError extends Error {
    constructor(message, lastResult) {
        super(`${message}. Last result: ${JSON.stringify(lastResult, null, 2)}`);
        this.lastResult = lastResult;
        this.name = 'MaxAttemptsExceededError';
    }
}
exports.MaxAttemptsExceededError = MaxAttemptsExceededError;
/**
 * Delay execution for specified milliseconds
 */
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
/**
 * Generic polling function that handles polling logic with configurable options
 * @param initialRequest Function that performs the initial API request
 * @param pollingRequest Function that performs subsequent polling requests
 * @param options Polling configuration options
 * @returns The final result of type T
 */
async function poll(initialRequest, pollingRequest, options = {}) {
    const { initialDelayMs, pollingIntervalMs, maxAttempts, timeoutMs, shouldStop, onPollingAttempt } = {
        ...DEFAULT_OPTIONS,
        ...options,
    };
    // Start timeout timer if specified
    const timeoutPromise = timeoutMs ?
        new Promise((_, reject) => {
            setTimeout(() => {
                reject(new PollingTimeoutError(`Polling timed out after ${timeoutMs}ms`, result));
            }, timeoutMs);
        })
        : null;
    // Initial request
    let result = await initialRequest();
    // Check if we should stop after initial request
    if (shouldStop?.(result)) {
        return result;
    }
    // Wait initial delay
    await delay(initialDelayMs);
    let attempts = 0;
    while (attempts < maxAttempts) {
        attempts++;
        // Create polling promise
        const pollingPromise = async () => {
            result = await pollingRequest();
            onPollingAttempt?.(attempts, result);
            if (shouldStop?.(result)) {
                return result;
            }
            if (attempts === maxAttempts) {
                throw new MaxAttemptsExceededError(`Polling exceeded maximum attempts (${maxAttempts})`, result);
            }
            await delay(pollingIntervalMs);
            return null;
        };
        // Race between polling and timeout if timeout is specified
        const pollingResult = timeoutPromise ? await Promise.race([pollingPromise(), timeoutPromise]) : await pollingPromise();
        if (pollingResult !== null) {
            return pollingResult;
        }
    }
    throw new MaxAttemptsExceededError(`Polling exceeded maximum attempts (${maxAttempts})`, result);
}
exports.poll = poll;
//# sourceMappingURL=polling.js.map