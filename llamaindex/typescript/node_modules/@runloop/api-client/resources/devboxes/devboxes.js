"use strict";
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DevboxSnapshotViewsDiskSnapshotsCursorIDPage = exports.DevboxViewsDevboxesCursorIDPage = exports.Devboxes = void 0;
const resource_1 = require("../../resource.js");
const core_1 = require("../../core.js");
const Core = __importStar(require("../../core.js"));
const ExecutionsAPI = __importStar(require("./executions.js"));
const executions_1 = require("./executions.js");
const LogsAPI = __importStar(require("./logs.js"));
const logs_1 = require("./logs.js");
const LspAPI = __importStar(require("./lsp.js"));
const lsp_1 = require("./lsp.js");
const pagination_1 = require("../../pagination.js");
const polling_1 = require("@runloop/api-client/lib/polling");
const __1 = require("../../index.js");
const tools_1 = require("./tools.js");
const DEVBOX_BOOTING_STATES = ['provisioning', 'initializing'];
class Devboxes extends resource_1.APIResource {
    constructor() {
        super(...arguments);
        this.lsp = new LspAPI.Lsp(this._client);
        this.logs = new LogsAPI.Logs(this._client);
        this.executions = new ExecutionsAPI.Executions(this._client);
    }
    create(body = {}, options) {
        if ((0, core_1.isRequestOptions)(body)) {
            return this.create({}, body);
        }
        return this._client.post('/v1/devboxes', { body, ...options });
    }
    /**
     * Get the latest details and status of a Devbox.
     */
    retrieve(id, options) {
        return this._client.get(`/v1/devboxes/${id}`, options);
    }
    /**
     * Wait for a devbox to reach the running state.
     * Polls the devbox status until it reaches running state or fails with an error.
     */
    async awaitRunning(id, options) {
        const finalResult = await (0, polling_1.poll)(() => this.retrieve(id, options), () => this.retrieve(id, options), {
            ...options?.polling,
            shouldStop: (result) => {
                return !DEVBOX_BOOTING_STATES.includes(result.status);
            },
        });
        // Now we check if the devbox is 'running' otherwise we throw an error
        if (finalResult.status !== 'running') {
            throw new __1.RunloopError(`Devbox ${id} is in non-running state ${finalResult.status}`);
        }
        return finalResult;
    }
    /**
     * Create a devbox and wait for it to reach the running state.
     * This is a convenience method that combines create() and awaitDevboxRunning().
     */
    async createAndAwaitRunning(body, options) {
        const devbox = await this.create(body, options);
        return this.awaitRunning(devbox.id, options);
    }
    list(query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list({}, query);
        }
        return this._client.getAPIList('/v1/devboxes', DevboxViewsDevboxesCursorIDPage, { query, ...options });
    }
    /**
     * Create an SSH key for a Devbox to enable remote access.
     */
    createSSHKey(id, options) {
        return this._client.post(`/v1/devboxes/${id}/create_ssh_key`, options);
    }
    /**
     * Create a live tunnel to an available port on the Devbox. Note the port must be
     * made available using Devbox.create.availablePorts. Otherwise, the tunnel will
     * not connect to any running processes on the Devbox.
     */
    createTunnel(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/create_tunnel`, { body, ...options });
    }
    /**
     * Delete a previously taken disk snapshot of a Devbox.
     */
    deleteDiskSnapshot(id, options) {
        return this._client.post(`/v1/devboxes/disk_snapshots/${id}/delete`, options);
    }
    /**
     * Download file contents of any type (binary, text, etc) from a specified path on
     * the Devbox.
     */
    downloadFile(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/download_file`, {
            body,
            ...options,
            headers: { Accept: 'application/octet-stream', ...options?.headers },
            __binaryResponse: true,
        });
    }
    /**
     * Execute the given command in the Devbox shell asynchronously and returns the
     * execution that can be used to track the command's progress.
     */
    executeAsync(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/execute_async`, { body, ...options });
    }
    /**
     * Execute a bash command in the Devbox shell, await the command completion and
     * return the output.
     */
    executeSync(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/execute_sync`, { body, ...options });
    }
    /**
     * Send a 'Keep Alive' signal to a running Devbox that is configured to shutdown on
     * idle so the idle time resets.
     */
    keepAlive(id, options) {
        return this._client.post(`/v1/devboxes/${id}/keep_alive`, options);
    }
    listDiskSnapshots(query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.listDiskSnapshots({}, query);
        }
        return this._client.getAPIList('/v1/devboxes/disk_snapshots', DevboxSnapshotViewsDiskSnapshotsCursorIDPage, { query, ...options });
    }
    /**
     * Read file contents from a file on a Devbox as a UTF-8. Note 'downloadFile'
     * should be used for large files (greater than 100MB). Returns the file contents
     * as a UTF-8 string.
     */
    readFileContents(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/read_file_contents`, {
            body,
            ...options,
            headers: { Accept: 'text/plain', ...options?.headers },
        });
    }
    /**
     * Remove a previously opened tunnel on the Devbox.
     */
    removeTunnel(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/remove_tunnel`, { body, ...options });
    }
    /**
     * Resume a suspended Devbox with the disk state captured as suspend time. Note
     * that any previously running processes or daemons will need to be restarted using
     * the Devbox shell tools.
     */
    resume(id, options) {
        return this._client.post(`/v1/devboxes/${id}/resume`, options);
    }
    /**
     * Shutdown a running Devbox. This will permanently stop the Devbox. If you want to
     * save the state of the Devbox, you should take a snapshot before shutting down or
     * should suspend the Devbox instead of shutting down.
     */
    shutdown(id, options) {
        return this._client.post(`/v1/devboxes/${id}/shutdown`, options);
    }
    snapshotDisk(id, body = {}, options) {
        if ((0, core_1.isRequestOptions)(body)) {
            return this.snapshotDisk(id, {}, body);
        }
        return this._client.post(`/v1/devboxes/${id}/snapshot_disk`, { body, ...options });
    }
    /**
     * Suspend a running Devbox and create a disk snapshot to enable resuming the
     * Devbox later with the same disk. Note this will not snapshot memory state such
     * as running processes.
     */
    suspend(id, options) {
        return this._client.post(`/v1/devboxes/${id}/suspend`, options);
    }
    /**
     * Upload file contents of any type (binary, text, etc) to a Devbox. Note this API
     * is suitable for large files (larger than 100MB) and efficiently uploads files
     * via multipart form data.
     */
    uploadFile(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/upload_file`, Core.multipartFormRequestOptions({ body, ...options }));
    }
    /**
     * Write UTF-8 string contents to a file at path on the Devbox. Note for large
     * files (larger than 100MB), the upload_file endpoint must be used.
     */
    writeFileContents(id, body, options) {
        return this._client.post(`/v1/devboxes/${id}/write_file_contents`, { body, ...options });
    }
    // Make an accessor for tools
    get tools() {
        return new tools_1.DevboxTools(this);
    }
}
exports.Devboxes = Devboxes;
class DevboxViewsDevboxesCursorIDPage extends pagination_1.DevboxesCursorIDPage {
}
exports.DevboxViewsDevboxesCursorIDPage = DevboxViewsDevboxesCursorIDPage;
class DevboxSnapshotViewsDiskSnapshotsCursorIDPage extends pagination_1.DiskSnapshotsCursorIDPage {
}
exports.DevboxSnapshotViewsDiskSnapshotsCursorIDPage = DevboxSnapshotViewsDiskSnapshotsCursorIDPage;
Devboxes.DevboxViewsDevboxesCursorIDPage = DevboxViewsDevboxesCursorIDPage;
Devboxes.DevboxSnapshotViewsDiskSnapshotsCursorIDPage = DevboxSnapshotViewsDiskSnapshotsCursorIDPage;
Devboxes.Lsp = lsp_1.Lsp;
Devboxes.Logs = logs_1.Logs;
Devboxes.Executions = executions_1.Executions;
//# sourceMappingURL=devboxes.js.map