import { consoleLogger } from "@llamaindex/env";
import { metadataDictToNode } from "../utils.js";
import { AzureAISearchVectorStoreConfig } from "./AzureAISearchVectorStoreConfig.js";
export class AzureQueryResultSearchBase {
    _query;
    fieldMapping;
    odataFilter;
    searchClient;
    constructor(query, fieldMapping, odataFilter, searchClient){
        this._query = query;
        this.fieldMapping = fieldMapping;
        this.odataFilter = odataFilter;
        this.searchClient = searchClient;
    }
    get selectFields() {
        return [
            this.fieldMapping["id"],
            this.fieldMapping["chunk"],
            this.fieldMapping["metadata"],
            this.fieldMapping["doc_id"]
        ];
    }
    createSearchQuery() {
        return "*";
    }
    createQueryVector() {
        return null;
    }
    async _createQueryResult(searchQuery, vectorQueries) {
        if (!vectorQueries) {
            vectorQueries = [];
        }
        if (!this.searchClient) {
            throw new Error("SearchClient is not set");
        }
        const searchResults = await this.searchClient.search(searchQuery, {
            top: this._query.similarityTopK,
            select: this.selectFields,
            filter: this.odataFilter || "",
            vectorSearchOptions: {
                queries: vectorQueries
            }
        });
        const idResult = [];
        const nodeResult = [];
        const scoreResult = [];
        for await (const result of searchResults.results){
            const { document } = result;
            // build node metadata from the metadata field in the document
            const nodeId = document[this.fieldMapping["id"]];
            const metadataStr = document[this.fieldMapping["metadata"]];
            const metadata = typeof metadataStr === "string" ? JSON.parse(metadataStr) : {};
            const score = result["score"];
            const chunk = document[this.fieldMapping["chunk"]];
            let node;
            try {
                node = metadataDictToNode(metadata);
                node.setContent(chunk);
                consoleLogger.log(`Retrieved node id ${nodeId}`);
                idResult.push(nodeId);
                nodeResult.push(node);
                scoreResult.push(score);
            } catch (err) {
                consoleLogger.error(`Error while parsing metadata for node id ${nodeId}. Error: ${err}`);
            }
        }
        consoleLogger.log(`Search query '${searchQuery}' returned ${idResult.length} results.`);
        return {
            nodes: nodeResult,
            similarities: scoreResult,
            ids: idResult
        };
    }
    async search() {
        const searchQuery = this.createSearchQuery();
        const vectorQueries = this.createQueryVector();
        return await this._createQueryResult(searchQuery, vectorQueries);
    }
}
export class AzureQueryResultSearchDefault extends AzureQueryResultSearchBase {
    createQueryVector() {
        if (!this._query.queryEmbedding) {
            throw new Error("query.queryEmbedding is missing");
        }
        return [
            {
                kind: "vector",
                vector: this._query.queryEmbedding,
                kNearestNeighborsCount: this._query.similarityTopK,
                fields: [
                    this.fieldMapping["embedding"]
                ]
            }
        ];
    }
}
export class AzureQueryResultSearchSparse extends AzureQueryResultSearchBase {
    createSearchQuery() {
        if (!this._query.queryStr) {
            throw new Error("Query missing query string");
        }
        return this._query.queryStr;
    }
}
export class AzureQueryResultSearchHybrid extends AzureQueryResultSearchBase {
    createQueryVector() {
        return new AzureQueryResultSearchDefault(this._query, this.fieldMapping, this.odataFilter, this.searchClient).createQueryVector();
    }
    createSearchQuery() {
        return new AzureQueryResultSearchSparse(this._query, this.fieldMapping, this.odataFilter, this.searchClient).createSearchQuery();
    }
}
export class AzureQueryResultSearchSemanticHybrid extends AzureQueryResultSearchHybrid {
    createQueryVector() {
        if (!this._query.queryEmbedding) {
            throw new Error("query.queryEmbedding is missing");
        }
        return [
            {
                kind: "vector",
                vector: this._query.queryEmbedding,
                // kNearestNeighborsCount is set to 50 to align with the number of accept document in azure semantic reranking model.
                // https://learn.microsoft.com/azure/search/semantic-search-overview
                kNearestNeighborsCount: 50,
                fields: [
                    this.fieldMapping["embedding"]
                ]
            }
        ];
    }
    async _createQueryResult(searchQuery, vectorQueries) {
        if (!this.searchClient) {
            throw new Error("SearchClient not set");
        }
        const searchResults = await this.searchClient.search(searchQuery, {
            vectorSearchOptions: {
                queries: vectorQueries
            },
            semanticSearchOptions: {
                configurationName: AzureAISearchVectorStoreConfig.SEMANTIC_CONFIG_NAME
            },
            top: this._query.similarityTopK,
            select: this.selectFields,
            filter: this.odataFilter || "",
            queryType: "semantic"
        });
        const idResult = [];
        const nodeResult = [];
        const scoreResult = [];
        for await (const result of searchResults.results){
            // build node metadata from the metadata field in the document
            const { document } = result;
            const nodeId = document[this.fieldMapping["id"]];
            const metadataStr = document[this.fieldMapping["metadata"]];
            const metadata = metadataStr ? JSON.parse(metadataStr) : {};
            const chunk = document[this.fieldMapping["chunk"]];
            const score = result["rerankerScore"];
            let node;
            try {
                node = metadataDictToNode(metadata);
                node.setContent(chunk);
                idResult.push(nodeId);
                nodeResult.push(node);
                scoreResult.push(score);
            } catch (err) {
                consoleLogger.error(`Error while parsing metadata for node id ${nodeId}. Error: ${err}`);
            }
        }
        return {
            nodes: nodeResult,
            similarities: scoreResult,
            ids: idResult
        };
    }
}
