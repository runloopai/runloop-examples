import { AzureKeyCredential, IndexDocumentsBatch, KnownAnalyzerNames, KnownSearchFieldDataType, KnownVectorSearchAlgorithmKind, KnownVectorSearchAlgorithmMetric, KnownVectorSearchCompressionKind, SearchClient, SearchIndexClient } from "@azure/search-documents";
import { DefaultAzureCredential, ManagedIdentityCredential } from "@azure/identity";
import { MetadataMode } from "@llamaindex/core/schema";
import { consoleLogger, getEnv } from "@llamaindex/env";
import { BaseVectorStore, FilterCondition, FilterOperator, VectorStoreQueryMode } from "../types.js";
import { metadataDictToNode, nodeToMetadata } from "../utils.js";
import { AzureAISearchVectorStoreConfig } from "./AzureAISearchVectorStoreConfig.js";
import { AzureQueryResultSearchDefault, AzureQueryResultSearchHybrid, AzureQueryResultSearchSemanticHybrid, AzureQueryResultSearchSparse } from "./AzureQueryResultSearch.js";
/**
 * Enumeration representing the supported index management operations
 */ export var IndexManagement = /*#__PURE__*/ function(IndexManagement) {
    IndexManagement["NO_VALIDATION"] = "NoValidation";
    IndexManagement["VALIDATE_INDEX"] = "ValidateIndex";
    IndexManagement["CREATE_IF_NOT_EXISTS"] = "CreateIfNotExists";
    return IndexManagement;
}({});
/**
 * Enumeration representing the supported types for metadata fields in an
 * Azure AI Search Index, corresponds with types supported in a flat
 * metadata dictionary.
 */ export var MetadataIndexFieldType = /*#__PURE__*/ function(MetadataIndexFieldType) {
    MetadataIndexFieldType["STRING"] = "Edm.String";
    MetadataIndexFieldType["BOOLEAN"] = "Edm.Boolean";
    MetadataIndexFieldType["INT32"] = "Edm.Int32";
    MetadataIndexFieldType["INT64"] = "Edm.Int64";
    MetadataIndexFieldType["DOUBLE"] = "Edm.Double";
    MetadataIndexFieldType["COLLECTION"] = "Collection(Edm.String)";
    return MetadataIndexFieldType;
}({});
const createSearchRequest = (fieldMapping, filterStr, batchSize, offset)=>{
    return {
        filter: filterStr,
        top: batchSize,
        skip: offset,
        select: Object.keys(fieldMapping)
    };
};
/**
 * Azure AI Search vector store.
 *
 * @example
```typescript
import { DefaultAzureCredential, getBearerTokenProvider} from "@azure/identity";
import {KnownAnalyzerNames, KnownVectorSearchAlgorithmKind } from "@azure/search-documents";

// 1- Setup Azure OpenAI
const azureADTokenProvider = getBearerTokenProvider(
  new DefaultAzureCredential(),
  "https://cognitiveservices.azure.com/.default",
);

// IMPORTANT: You need to deploy your own embedding model as well as your own chat completion model
// NOTE: You can use whatever embedding model and language model that is supported in LlamaIndex
const azure = {
  azureADTokenProvider,
  deployment: process.env.AZURE_DEPLOYMENT_NAME,
};
Settings.llm = new OpenAI({ azure });
Settings.embedModel = new OpenAIEmbedding({
  model: process.env.EMBEDDING_MODEL,
  azure: {
    ...azure,
    deployment: process.env.EMBEDDING_MODEL,
  },
});

// ---------------------------------------------------------
// 2- Setup Azure AI Search
// Define env variables in .env file
// AZURE_AI_SEARCH_ENDPOINT=
// AZURE_AI_SEARCH_KEY=
// AZURE_OPENAI_ENDPOINT=
// EMBEDDING_MODEL=text-embedding-ada-002
// AZURE_DEPLOYMENT_NAME=gpt-4
// AZURE_API_VERSION=2024-09-01-preview

// Define index name
const indexName = "llamaindex-vector-store";

// ---------------------------------------------------------
// 3a- Create Index (if it does not exist)
// id:	      Edm.String
// chunk:	    Edm.String
// embedding:	Collection(Edm.Single)
// metadata:	Edm.String
// doc_id:	  Edm.String
// author:	  Edm.String
// theme:	    Edm.String
// director:	Edm.String

// Define metadata fields with their respective configurations
const metadataFields = {
  author: "author",
  theme: ["theme", MetadataIndexFieldType.STRING],
  director: "director",
};

// Define index parameters and vector store configuration
// Index validation:
// - IndexManagement.VALIDATE_INDEX: will validate before creating emnbedding index and will throw a runtime error if the index does not exist
// - IndexManagement.NO_VALIDATION: will try to access the index and will throw a runtime error if the index does not exist
// - IndexManagement.CREATE_IF_NOT_EXISTS: will create the index if it does not exist

const vectorStore = new AzureAISearchVectorStore({
  filterableMetadataFieldKeys:
    metadataFields as unknown as FilterableMetadataFieldKeysType,
  indexName,
  indexManagement: IndexManagement.CREATE_IF_NOT_EXISTS,
  idFieldKey: "id",
  chunkFieldKey: "chunk",
  embeddingFieldKey: "embedding",
  metadataStringFieldKey: "metadata",
  docIdFieldKey: "doc_id",
  embeddingDimensionality: 1536,
  hiddenFieldKeys: ["embedding"],
  languageAnalyzer: KnownAnalyzerNames.EnLucene,
  // store vectors on disk
  vectorAlgorithmType: KnownVectorSearchAlgorithmKind.ExhaustiveKnn,

  // Optional: Set to "scalar" or "binary" if using HNSW
  compressionType: KnownVectorSearchCompressionKind.BinaryQuantization,
});

// ---------------------------------------------------------
// 3a- Loading documents
// Load the documents stored in the data/paul_graham/ using the SimpleDirectoryReader
// NOTE: You can use whatever reader that is supported in LlamaIndex

// Load documents using a directory reader
const documents = await new SimpleDirectoryReader().loadData(
  "data/paul_graham/",
);
const storageContext = await storageContextFromDefaults({ vectorStore });

// Create index from documents with the specified storage context
const index = await VectorStoreIndex.fromDocuments(documents, {
  storageContext,
  docStoreStrategy: DocStoreStrategy.UPSERTS,
});

const queryEngine = index.asQueryEngine();
const response = await queryEngine.query({
  query: "What did the author do growing up?",
  similarityTopK: 3,
} as any);
console.log({ response });
 */ export class AzureAISearchVectorStore extends BaseVectorStore {
    storesText = true;
    _searchClient;
    #languageAnalyzer;
    #embeddingDimensionality;
    #vectorProfileName;
    #compressionType;
    _indexClient;
    #indexManagement;
    #indexName;
    #fieldMapping;
    #metadataToIndexFieldMap = new Map();
    flatMetadata = true;
    #idFieldKey;
    #chunkFieldKey;
    #embeddingFieldKey;
    #docIdFieldKey;
    #metadataStringFieldKey;
    #serviceApiVersion;
    #indexMapping;
    #hiddenFiledKeys;
    constructor(options){
        super(options);
        // set default values
        options.vectorAlgorithmType ||= KnownVectorSearchAlgorithmKind.ExhaustiveKnn;
        options.languageAnalyzer ||= KnownAnalyzerNames.EnLucene;
        options.indexManagement ||= "NoValidation";
        options.embeddingDimensionality ||= 1536;
        options.serviceApiVersion ||= getEnv("AZURE_SEARCH_API_VERSION");
        options.hiddenFieldKeys ||= [];
        // set props
        this.#serviceApiVersion = options.serviceApiVersion || AzureAISearchVectorStoreConfig.DEFAULT_AZURE_API_VERSION;
        this.#languageAnalyzer = options.languageAnalyzer;
        this.#compressionType = options.compressionType;
        this.#embeddingDimensionality = options.embeddingDimensionality;
        this.#indexManagement = options.indexManagement;
        this.#indexName = options.indexName;
        this.#idFieldKey = options.idFieldKey;
        this.#docIdFieldKey = options.docIdFieldKey;
        this.#chunkFieldKey = options.chunkFieldKey;
        this.#embeddingFieldKey = options.embeddingFieldKey;
        this.#metadataStringFieldKey = options.metadataStringFieldKey;
        this.#hiddenFiledKeys = options.hiddenFieldKeys;
        this.#indexMapping = options.indexMapping || this.#defaultIndexMapping;
        // Default field mapping
        this.#fieldMapping = {
            ["id"]: options.idFieldKey,
            ["doc_id"]: options.docIdFieldKey,
            ["chunk"]: options.chunkFieldKey,
            ["embedding"]: options.embeddingFieldKey,
            ["metadata"]: options.metadataStringFieldKey
        };
        this.#setVectorProfileName(options.vectorAlgorithmType);
        this.#valideSearchOrIndexClient(options);
        // Normalizing metadata to index fields
        this.#metadataToIndexFieldMap = this.#normalizeMetadataToIndexFields(options.filterableMetadataFieldKeys);
    }
    // private
    #normalizeMetadataToIndexFields(filterableMetadataFieldKeys) {
        const indexFieldSpec = new Map();
        if (Array.isArray(filterableMetadataFieldKeys)) {
            // if filterableMetadataFieldKeys is an array, use the field name as the index field name
            // eg. [
            //  "author",
            //  "theme",
            //  "director"
            // ] => {
            //  "author": ["author", "Edm.String"],
            //  "theme": ["theme", "Edm.String"],
            //  "director": ["director", "Edm.String"]
            // }
            filterableMetadataFieldKeys.forEach((field)=>{
                indexFieldSpec.set(field, [
                    field,
                    "Edm.String"
                ]);
            });
        } else if (typeof filterableMetadataFieldKeys === "object") {
            // if filterableMetadataFieldKeys is an object, use the key as the index field name
            // and the value as the metadata field name
            // eg. {
            //  "author": "author",
            //  "theme": ["topic", MetadataIndexFieldType.STRING],
            //  "director": "director"
            // } => {
            //  "author": ["author", "Edm.String"],
            //  "theme": ["topic", "Edm.String"],
            //  "director": ["director", "Edm.String"]
            // }
            // we also support specifying the metadata field type
            // MetadataIndexFieldType.INT32 --> "Edm.Int32"
            // MetadataIndexFieldType.INT64 --> "Edm.Int64"
            // MetadataIndexFieldType.DOUBLE --> "Edm.Double"
            // MetadataIndexFieldType.BOOLEAN --> "Edm.Boolean"
            // MetadataIndexFieldType.COLLECTION --> "Collection(Edm.String)"
            Object.entries(filterableMetadataFieldKeys).forEach(([k, v])=>{
                if (Array.isArray(v)) {
                    indexFieldSpec.set(k, [
                        v[0],
                        v[1]
                    ]);
                } else {
                    switch(v){
                        case "Edm.String":
                            indexFieldSpec.set(k, [
                                v,
                                "Edm.String"
                            ]);
                            break;
                        case "Edm.Int32":
                            indexFieldSpec.set(k, [
                                v,
                                "Edm.Int32"
                            ]);
                            break;
                        case "Edm.Int64":
                            indexFieldSpec.set(k, [
                                v,
                                "Edm.Int64"
                            ]);
                            break;
                        case "Edm.Double":
                            indexFieldSpec.set(k, [
                                v,
                                "Edm.Double"
                            ]);
                            break;
                        case "Edm.Boolean":
                            indexFieldSpec.set(k, [
                                v,
                                "Edm.Boolean"
                            ]);
                            break;
                        case "Collection(Edm.String)":
                            indexFieldSpec.set(k, [
                                v,
                                "Collection(Edm.String)"
                            ]);
                            break;
                        default:
                            // Index field name and metadata field name may differ
                            // Use String as the default index field type
                            indexFieldSpec.set(k, [
                                v,
                                "Edm.String"
                            ]);
                            break;
                    }
                }
            });
        }
        return indexFieldSpec;
    }
    #defaultIndexMapping(node, metadata) {
        // include metadata fields in the index document
        const filterableMetadata = {};
        for (const [fieldName, _fieldType] of this.#metadataToIndexFieldMap.values()){
            filterableMetadata[fieldName] = metadata[fieldName];
        }
        return {
            [this.#embeddingFieldKey]: node.getEmbedding(),
            [this.#idFieldKey]: node.id_,
            [this.#docIdFieldKey]: node.id_,
            [this.#chunkFieldKey]: node.getContent(MetadataMode.NONE),
            [this.#metadataStringFieldKey]: JSON.stringify(metadata),
            ...filterableMetadata
        };
    }
    #setVectorProfileName(vectorAlgorithmType) {
        if (vectorAlgorithmType === KnownVectorSearchAlgorithmKind.ExhaustiveKnn) {
            this.#vectorProfileName = "myExhaustiveKnnProfile";
        } else if (vectorAlgorithmType === KnownVectorSearchAlgorithmKind.Hnsw) {
            this.#vectorProfileName = "myHnswProfile";
        } else {
            throw new Error("Only 'exhaustiveKnn' and 'hnsw' are supported for vectorAlgorithmType");
        }
    }
    /**
   * Create a list of index fields for storing metadata values.
   * @returns List of index fields for storing metadata values
   */ #createMetadataIndexFields() {
        const indexFields = [];
        for (const [fieldName, fieldType] of this.#metadataToIndexFieldMap.values()){
            if (this.#fieldMapping[fieldName]) {
                consoleLogger.log(`Skipping metadata field ${fieldName} as it is already mapped to an index field`);
                continue;
            }
            let indexFieldType;
            switch(fieldType){
                case "Edm.String":
                    indexFieldType = KnownSearchFieldDataType.String;
                    break;
                case "Edm.Int32":
                    indexFieldType = KnownSearchFieldDataType.Int32;
                    break;
                case "Edm.Int64":
                    indexFieldType = KnownSearchFieldDataType.Int64;
                    break;
                case "Edm.Double":
                    indexFieldType = KnownSearchFieldDataType.Double;
                    break;
                case "Edm.Boolean":
                    indexFieldType = KnownSearchFieldDataType.Boolean;
                    break;
                case "Collection(Edm.String)":
                    indexFieldType = `Collection(${KnownSearchFieldDataType.String})`;
                    break;
                default:
                    throw new Error(`Unsupported field type: ${fieldType}`);
            }
            indexFields.push({
                name: fieldName,
                type: indexFieldType,
                filterable: true
            });
        }
        return indexFields;
    }
    // index management
    async #indexExists(indexName) {
        if (!indexName) {
            throw new Error(`options.indexName is not valid`);
        }
        const availableIndexNames = await this._indexClient?.listIndexesNames();
        if (!availableIndexNames) {
            return false;
        }
        let listOfIndexNames = await availableIndexNames.next();
        const indexNames = [];
        while(!listOfIndexNames.done){
            indexNames.push(listOfIndexNames.value);
            listOfIndexNames = await availableIndexNames.next();
        }
        return indexNames.includes(indexName);
    }
    async #createIndexIfNotExists(indexName) {
        const indexExists = await this.#indexExists(indexName);
        if (!indexExists) {
            consoleLogger.log(`Index ${indexName} does not exist in Azure AI Search, creating index`);
            await this.#createIndex(indexName);
        }
    }
    /**
   * Creates a default index based on the supplied index name, key field names and
   * metadata filtering keys.
   * @param indexName The name of the index to create
   */ async #createIndex(indexName) {
        consoleLogger.log(`Configuring ${indexName} fields for Azure AI Search`);
        const fields = [
            {
                name: this.#fieldMapping["id"],
                type: KnownSearchFieldDataType.String,
                hidden: this.#hiddenFiledKeys?.includes(this.#fieldMapping["id"]),
                key: true,
                filterable: true,
                retrievable: true,
                searchable: true
            },
            {
                name: this.#fieldMapping["chunk"],
                type: KnownSearchFieldDataType.String,
                hidden: this.#hiddenFiledKeys?.includes(this.#fieldMapping["chunk"]),
                analyzerName: this.#languageAnalyzer,
                searchable: true
            },
            {
                name: this.#fieldMapping["embedding"],
                type: `Collection(${KnownSearchFieldDataType.Single})`,
                vectorSearchDimensions: this.#embeddingDimensionality,
                vectorSearchProfileName: this.#vectorProfileName,
                hidden: this.#hiddenFiledKeys?.includes(this.#fieldMapping["embedding"]),
                searchable: true
            },
            {
                name: this.#fieldMapping["metadata"],
                hidden: this.#hiddenFiledKeys?.includes(this.#fieldMapping["metadata"]),
                type: KnownSearchFieldDataType.String
            },
            {
                name: this.#fieldMapping["doc_id"],
                type: KnownSearchFieldDataType.String,
                hidden: this.#hiddenFiledKeys?.includes(this.#fieldMapping["doc_id"]),
                filterable: true,
                retrievable: true,
                searchable: true
            }
        ];
        consoleLogger.log(`Configuring ${indexName} metadata fields`);
        const metadataIndexFields = this.#createMetadataIndexFields();
        fields.push(...metadataIndexFields);
        consoleLogger.log(`Configuring ${indexName} vector search`);
        const compressions = this.#getCompressions();
        consoleLogger.log(`Configuring ${indexName} vector search with ${this.#compressionType} compression`);
        const vectorSearch = {
            algorithms: [
                {
                    name: AzureAISearchVectorStoreConfig.ALGORITHM_HNSW_NAME,
                    kind: KnownVectorSearchAlgorithmKind.Hnsw,
                    parameters: {
                        m: 4,
                        efConstruction: 400,
                        efSearch: 500,
                        metric: KnownVectorSearchAlgorithmMetric.Cosine
                    }
                },
                {
                    name: AzureAISearchVectorStoreConfig.ALGORITHM_EXHAUSTIVE_KNN_NAME,
                    kind: KnownVectorSearchAlgorithmKind.ExhaustiveKnn,
                    parameters: {
                        metric: KnownVectorSearchAlgorithmMetric.Cosine
                    }
                }
            ],
            compressions,
            profiles: [
                {
                    name: AzureAISearchVectorStoreConfig.PROFILE_HNSW_NAME,
                    algorithmConfigurationName: AzureAISearchVectorStoreConfig.ALGORITHM_HNSW_NAME,
                    compressionName: compressions?.[0]?.compressionName
                },
                {
                    name: AzureAISearchVectorStoreConfig.PROFILE_EXHAUSTIVE_KNN_NAME,
                    algorithmConfigurationName: AzureAISearchVectorStoreConfig.ALGORITHM_EXHAUSTIVE_KNN_NAME
                }
            ]
        };
        consoleLogger.log(`Configuring ${indexName} semantic search`);
        const semanticConfig = {
            name: AzureAISearchVectorStoreConfig.SEMANTIC_CONFIG_NAME,
            prioritizedFields: {
                contentFields: [
                    {
                        name: this.#fieldMapping["chunk"]
                    }
                ],
                keywordsFields: [
                    {
                        name: this.#fieldMapping["metadata"]
                    }
                ],
                titleField: {
                    name: this.#fieldMapping["id"]
                }
            }
        };
        const semanticSearch = {
            configurations: [
                semanticConfig
            ]
        };
        const index = {
            name: indexName,
            fields: fields,
            vectorSearch: vectorSearch,
            semanticSearch: semanticSearch
        };
        consoleLogger.log(`Creating ${indexName} search index with configuration:`);
        consoleLogger.log({
            index
        });
        await this._indexClient?.createIndex(index);
    }
    /**
   * Get the compressions for the vector search
   * @returns Array of compressions. See {@link VectorSearchCompression}
   */ #getCompressions() {
        const compressions = [];
        if (this.#compressionType === KnownVectorSearchCompressionKind.BinaryQuantization) {
            compressions.push({
                compressionName: AzureAISearchVectorStoreConfig.COMPRESSION_TYPE_BINARY,
                kind: KnownVectorSearchCompressionKind.BinaryQuantization
            });
        } else if (this.#compressionType === KnownVectorSearchCompressionKind.ScalarQuantization) {
            compressions.push({
                compressionName: AzureAISearchVectorStoreConfig.COMPRESSION_TYPE_SCALAR,
                kind: KnownVectorSearchCompressionKind.ScalarQuantization
            });
        }
        return compressions;
    }
    #valideSearchOrIndexClient(options) {
        if (options.searchClient) {
            if (options.searchClient instanceof SearchClient) {
                consoleLogger.log("Using provided Azure SearchClient");
                this._searchClient = options.searchClient;
                if (options.indexName) {
                    throw new Error("options.indexName cannot be supplied if using options.searchClient");
                }
            } else {
                throw new Error("options.searchClient must be an instance of SearchClient");
            }
        } else {
            this.createSearchClient(options);
        }
        if (options.indexClient) {
            if (options.indexClient instanceof SearchIndexClient) {
                if (!options.indexName) {
                    throw new Error("options.indexName must be supplied if using options.indexClient");
                }
                this._indexClient = options.indexClient;
            } else {
                throw new Error("options.indexClient must be an instance of SearchIndexClient");
            }
        } else {
            this.createSearchIndexClient(options);
        }
        if (options.indexManagement === "CreateIfNotExists" && !this._indexClient) {
            throw new Error("IndexManagement.CREATE_IF_NOT_EXISTS requires options.indexClient");
        }
        if (!this._searchClient && !this._indexClient) {
            throw new Error("Either options.searchClient or options.indexClient must be supplied");
        }
    }
    #buildCredentials(options) {
        let { credential: credential, key, endpoint, indexName } = options;
        // validate and use credential
        if (credential) {
            // if credential are provided, ensure they are an instance of valid credential instances
            if (!(credential instanceof AzureKeyCredential || credential instanceof DefaultAzureCredential || credential instanceof ManagedIdentityCredential)) {
                throw new Error("options.credential must be an instance of AzureKeyCredential or DefaultAzureCredential or ManagedIdentityCredential");
            }
        } else {
            key ??= getEnv("AZURE_AI_SEARCH_KEY");
            if (key) {
                consoleLogger.log("Using provided Azure Search key");
                credential = new AzureKeyCredential(key);
            } else {
                const clientId = getEnv("AZURE_CLIENT_ID");
                if (clientId) {
                    consoleLogger.log("Using Azure Managed identity");
                    credential = new ManagedIdentityCredential(clientId);
                } else {
                    // if key wasn't provided, try using DefaultAzureCredential
                    consoleLogger.log("Using Default Azure Credential");
                    credential = new DefaultAzureCredential();
                }
            }
        }
        // validate and use endpoint
        endpoint ??= getEnv("AZURE_AI_SEARCH_ENDPOINT");
        if (!endpoint) {
            throw new Error("options.endpoint must be provided or set as an environment variable: AZURE_AI_SEARCH_ENDPOINT");
        } else {
            // check if enpoint is a valid URL
            try {
                new URL(endpoint);
            } catch (error) {
                throw new Error(`options.endpoint must be a valid URL.`);
            }
        }
        // validate and use indexName
        if (!indexName) {
            if (this._searchClient) {
                indexName = this._searchClient.indexName;
            } else {
                throw new Error("options.indexName must be provided");
            }
        }
        return {
            credential,
            endpoint,
            indexName
        };
    }
    createSearchIndexClient(options) {
        const { credential, endpoint } = this.#buildCredentials(options);
        this._indexClient = new SearchIndexClient(endpoint, credential, {
            serviceVersion: this.#serviceApiVersion,
            userAgentOptions: {
                userAgentPrefix: options.userAgent ?? AzureAISearchVectorStoreConfig.DEFAULT_USER_AGENT_PREFIX
            }
        });
    }
    createSearchClient(options) {
        const { credential, endpoint, indexName } = this.#buildCredentials(options);
        this._searchClient = new SearchClient(endpoint, indexName, credential, {
            serviceVersion: this.#serviceApiVersion,
            userAgentOptions: {
                userAgentPrefix: options.userAgent ?? AzureAISearchVectorStoreConfig.DEFAULT_USER_AGENT_PREFIX
            }
        });
    }
    async #validateIndex(indexName) {
        if (this._indexClient && indexName && !await this.#indexExists(indexName)) {
            throw new Error(`Validation failed, index ${indexName} does not exist.`);
        }
    }
    /**
   * Create AI Search index document from embedding result.
   * @param node The node to create the index document from
   * @returns The mapped index document from the node
   */ #createIndexDocument(node) {
        consoleLogger.log(`Mapping indexed document: ${node.id_}`);
        const metadata = nodeToMetadata(node, true, this.#chunkFieldKey, this.flatMetadata);
        return this.#indexMapping(node, metadata);
    }
    /**
   * Generate an OData filter string using supplied metadata filters.
   * @param metadataFilters
   * @returns
   */ #createOdataFilter(metadataFilters) {
        const odataFilter = [];
        for (const subfilter of metadataFilters.filters){
            // Join values with ' or ' to create an OR condition inside the any function
            const metadataMapping = this.#metadataToIndexFieldMap.get(subfilter.key);
            if (!metadataMapping) {
                throw new Error(`Metadata field '${subfilter.key}' is missing a mapping to an index field. Please provide an entry in 'filterableMetadataFieldKeys' for this vector store.`);
            }
            const indexField = metadataMapping[0];
            if (subfilter.operator === FilterOperator.IN) {
                let valueStr;
                if (Array.isArray(subfilter.value)) {
                    valueStr = subfilter.value.map((value)=>typeof value === "string" ? `t eq '${value}'` : `t eq ${value}`).join(" or ");
                } else {
                    valueStr = typeof subfilter.value === "string" ? `t eq '${subfilter.value}'` : `t eq ${subfilter.value}`;
                }
                odataFilter.push(`${indexField}/any(t: ${valueStr})`);
            } else if (subfilter.operator === FilterOperator.EQ) {
                const escapedValue = typeof subfilter.value === "string" ? subfilter.value.replace(/'/g, "''") : subfilter.value;
                odataFilter.push(`${indexField} eq '${escapedValue}'`);
            } else {
                throw new Error(`Unsupported filter operator ${subfilter.operator}. Supported operators are 'IN' and 'EQ'`);
            }
        }
        let odataExpr = "";
        if (metadataFilters.condition === FilterCondition.AND) {
            odataExpr = odataFilter.join(" and ");
        } else if (metadataFilters.condition === FilterCondition.OR) {
            odataExpr = odataFilter.join(" or ");
        } else {
            throw new Error(`Unsupported filter condition ${metadataFilters.condition}. Supported conditions are 'AND' and 'OR'`);
        }
        consoleLogger.log(`OData filter: ${odataExpr}`);
        return odataExpr;
    }
    #createNodeFromResult(result, fieldMapping) {
        const { document } = result;
        const metadataStr = document[fieldMapping["metadata"]];
        const metadata = metadataStr ? JSON.parse(metadataStr) : {};
        try {
            const node = metadataDictToNode(metadata);
            node.setContent(document[fieldMapping["chunk"]]);
            node.embedding = document[fieldMapping["embedding"]];
            return node;
        } catch (error) {
            throw new Error(`Failed to create node from search result`);
        }
    }
    #buildFilterString(fieldMapping, nodeIds, filters) {
        let filterStr = "";
        if (nodeIds && nodeIds.length > 0) {
            filterStr = nodeIds.map((nodeId)=>`${fieldMapping["id"]} eq '${nodeId}'`).join(" or ");
        }
        if (filters) {
            const metadataFilter = this.#createOdataFilter(filters);
            if (filterStr) {
                filterStr = `(${filterStr}) or (${metadataFilter})`;
            } else {
                filterStr = metadataFilter;
            }
        }
        return filterStr;
    }
    #processBatchResults(batchNodes, nodes, batchSize, limit) {
        if (batchNodes.length === 0) {
            return [
                nodes,
                false
            ];
        }
        nodes = [
            ...nodes,
            ...batchNodes
        ];
        // If we've hit the requested limit, stop
        if (limit && nodes.length >= limit) {
            return [
                nodes.slice(0, limit),
                false
            ];
        }
        // If we got fewer results than batch size, we've hit the end
        if (batchNodes.length < batchSize) {
            return [
                nodes,
                false
            ];
        }
        return [
            nodes,
            true
        ];
    }
    // public
    /**
   * Get search client
   * @returns Azure AI Search client. See {@link SearchClient}
   */ client() {
        return this._searchClient;
    }
    /**
   * Get index client
   * @returns Azure AI Search index client. See {@link SearchIndexClient}
   */ indexClient() {
        return this._indexClient;
    }
    /**
   * Add nodes to index associated with the configured search client.
   * @param nodes List of nodes with embeddings to add to the index
   * @returns List of node IDs that were added to the index
   */ async add(nodes) {
        if (!this._searchClient) {
            throw new Error("Async Search client not initialized");
        }
        if (!nodes || nodes.length === 0) {
            return [];
        }
        if (nodes.length > 0) {
            if (this.#indexManagement === "CreateIfNotExists" && this.#indexName) {
                await this.#createIndexIfNotExists(this.#indexName);
            }
            if (this.#indexManagement === "ValidateIndex") {
                await this.#validateIndex(this.#indexName);
            }
        }
        const accumulator = new IndexDocumentsBatch();
        let documents = [];
        const ids = [];
        let accumulatedSize = 0;
        const maxSize = AzureAISearchVectorStoreConfig.DEFAULT_MAX_MB_SIZE;
        const maxDocs = AzureAISearchVectorStoreConfig.DEFAULT_MAX_BATCH_SIZE;
        for (const node of nodes){
            consoleLogger.log(`Processing embedding: ${node.id_}`);
            const indexDocument = this.#createIndexDocument(node);
            const documentSize = JSON.stringify(indexDocument).length; // in bytes
            documents.push(indexDocument);
            accumulatedSize += documentSize;
            accumulator.upload(documents);
            if (documents.length >= maxDocs || accumulatedSize >= maxSize) {
                consoleLogger.log(`Uploading batch of size ${documents.length}, current progress ${ids.length} of ${nodes.length}, accumulated size ${(accumulatedSize / (1024 * 1024)).toFixed(2)} MB`);
                await this._searchClient.indexDocuments(accumulator);
                documents = [];
                accumulatedSize = 0;
            }
            ids.push(node.id_);
        }
        if (documents.length > 0) {
            consoleLogger.log(`Uploading remaining batch of size ${documents.length}, current progress ${ids.length} of ${nodes.length}, accumulated size ${(accumulatedSize / (1024 * 1024)).toFixed(2)} MB`);
            await this._searchClient.indexDocuments(accumulator);
        }
        return ids;
    }
    /**
   * Delete documents from the AI Search Index with docIdFieldKey (doc_id) field equal to refDocId.
   * @param refDocId The reference document ID to delete from the index
   */ async delete(refDocId) {
        // Check if index exists
        if (!await this.#indexExists(this.#indexName)) {
            return;
        }
        if (!this._searchClient) {
            throw new Error("searchClient is not initialized");
        }
        // Define filter and batch size
        const filterExpr = `${this.#fieldMapping["doc_id"]} eq '${refDocId}'`;
        const batchSize = 1000;
        while(true){
            // Search for documents to delete
            consoleLogger.log(`Searching with filter ${filterExpr}`);
            const searchResults = await this._searchClient.search("*", {
                filter: filterExpr,
                top: batchSize
            });
            // Collect document IDs to delete
            const docsToDelete = [];
            for await (const result of searchResults.results){
                const { document } = result;
                docsToDelete.push(document);
            }
            // Delete documents if found
            if (docsToDelete.length > 0) {
                consoleLogger.log(`Deleting ${docsToDelete.length} documents`);
                await this._searchClient.deleteDocuments(docsToDelete);
            } else {
                consoleLogger.log("No documents found to delete");
                break;
            }
        }
    }
    /**
   * Get nodes asynchronously from the Azure AI Search index.
   * @param nodeIds List of node IDs to retrieve from the index
   * @param filters Metadata filters to apply to the search
   * @param limit Maximum number of nodes to retrieve
   * @returns List of nodes retrieved from the index
   */ async getNodes(nodeIds, filters, limit) {
        if (!this._searchClient) {
            throw new Error("SearchClient not initialized");
        }
        const filterStr = this.#buildFilterString(this.#fieldMapping, nodeIds, filters);
        const nodes = [];
        const batchSize = 1000; // Azure Search batch size limit
        while(true){
            try {
                const searchRequest = createSearchRequest(this.#fieldMapping, filterStr, batchSize, nodes.length);
                const results = await this._searchClient.search("*", searchRequest);
                const batchNodes = [];
                for await (const result of results.results){
                    batchNodes.push(this.#createNodeFromResult(result, this.#fieldMapping));
                }
                const [updatedNodes, continueFetching] = this.#processBatchResults(batchNodes, nodes, batchSize, limit);
                nodes.push(...updatedNodes);
                if (!continueFetching) {
                    break;
                }
            } catch (error) {
                throw new Error(`Failed to get nodes from Azure AI Search: ${error}`);
            }
        }
        return nodes;
    }
    async query(query) {
        let odataFilter;
        if (query.filters) {
            odataFilter = this.#createOdataFilter(query.filters);
            consoleLogger.log(`Querying with OData filter: ${odataFilter}`);
        }
        consoleLogger.log({
            query
        });
        // Define base AzureQueryResultSearch object based on query mode
        let azureQueryResultSearch = new AzureQueryResultSearchDefault(query, this.#fieldMapping, odataFilter, this._searchClient);
        switch(query.mode){
            case VectorStoreQueryMode.SPARSE:
                azureQueryResultSearch = new AzureQueryResultSearchSparse(query, this.#fieldMapping, odataFilter, this._searchClient);
                break;
            case VectorStoreQueryMode.HYBRID:
                azureQueryResultSearch = new AzureQueryResultSearchHybrid(query, this.#fieldMapping, odataFilter, this._searchClient);
                break;
            case VectorStoreQueryMode.SEMANTIC_HYBRID:
                azureQueryResultSearch = new AzureQueryResultSearchSemanticHybrid(query, this.#fieldMapping, odataFilter, this._searchClient);
                break;
        }
        // Execute the search and return the result
        return await azureQueryResultSearch.search();
    }
}
