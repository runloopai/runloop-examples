import { CosmosClient } from "@azure/cosmos";
import { DefaultAzureCredential } from "@azure/identity";
import { BaseChatStore } from "@llamaindex/core/storage/chat-store";
import { getEnv } from "@llamaindex/env";
const USER_AGENT_SUFFIX = "llamaindex-cdbnosql-chatstore-javascript";
const DEFAULT_CHAT_DATABASE = "ChatMessagesDB";
const DEFAULT_CHAT_CONTAINER = "ChatMessagesContainer";
const DEFAULT_OFFER_THROUGHPUT = 400;
function parseConnectionString(connectionString) {
    const parts = connectionString.split(";");
    let endpoint = "";
    let accountKey = "";
    parts.forEach((part)=>{
        const [key, value] = part.split("=");
        if (key && key.trim() === "AccountEndpoint") {
            endpoint = value?.trim() ?? "";
        } else if ((key ?? "").trim() === "AccountKey") {
            accountKey = value?.trim() ?? "";
        }
    });
    if (!endpoint || !accountKey) {
        throw new Error("Invalid connection string: missing AccountEndpoint or AccountKey.");
    }
    return {
        endpoint,
        key: accountKey
    };
}
export class AzureCosmosNoSqlChatStore extends BaseChatStore {
    userId;
    ttl;
    cosmosClient;
    database;
    container;
    initPromise;
    dbName;
    containerName;
    cosmosContainerProperties;
    cosmosDatabaseProperties;
    initialize;
    constructor({ cosmosClient, dbName = DEFAULT_CHAT_DATABASE, containerName = DEFAULT_CHAT_CONTAINER, cosmosContainerProperties = {
        partitionKey: "/userId"
    }, cosmosDatabaseProperties = {}, ttlInSeconds = -1 }){
        super();
        if (!cosmosClient) {
            throw new Error("CosmosClient is required for AzureCosmosDBNoSQLChatStore initialization");
        }
        this.ttl = ttlInSeconds;
        this.userId = cosmosContainerProperties.userId || "anonymous";
        this.cosmosClient = cosmosClient;
        this.dbName = dbName;
        this.containerName = containerName;
        this.cosmosContainerProperties = cosmosContainerProperties;
        this.cosmosDatabaseProperties = cosmosDatabaseProperties;
        this.initialize = ()=>{
            if (this.initPromise === undefined) {
                this.initPromise = this.init().catch((error)=>{
                    console.error("Error during AzureCosmosDBNoSQLChatStore initialization", error);
                });
            }
            return this.initPromise;
        };
    }
    client() {
        return this.cosmosClient;
    }
    // Asynchronous initialization method to create database and container
    async init() {
        // Set default throughput if not provided
        const throughput = this.cosmosDatabaseProperties?.throughput || DEFAULT_OFFER_THROUGHPUT;
        // Create the database if it doesn't exist
        const { database } = await this.cosmosClient.databases.createIfNotExists({
            id: this.dbName,
            throughput
        });
        this.database = database;
        // Create the container if it doesn't exist
        const { container } = await this.database.containers.createIfNotExists({
            id: this.containerName,
            throughput: this.cosmosContainerProperties?.throughput,
            partitionKey: "/userId",
            indexingPolicy: this.cosmosContainerProperties?.indexingPolicy,
            defaultTtl: this.ttl,
            uniqueKeyPolicy: this.cosmosContainerProperties?.uniqueKeyPolicy,
            conflictResolutionPolicy: this.cosmosContainerProperties?.conflictResolutionPolicy,
            computedProperties: this.cosmosContainerProperties?.computedProperties
        });
        this.container = container;
    }
    /**
   * Static method for creating an instance using a connection string.
   * If no connection string is provided, it will attempt to use the env variable `AZURE_COSMOSDB_NOSQL_CONNECTION_STRING` as connection string.
   * @returns Instance of AzureCosmosNoSqlKVStore
   */ static fromConnectionString(config = {}) {
        const cosmosConnectionString = config.connectionString || getEnv("AZURE_COSMOSDB_NOSQL_CONNECTION_STRING");
        if (!cosmosConnectionString) {
            throw new Error("Azure CosmosDB connection string must be provided");
        }
        const { endpoint, key } = parseConnectionString(cosmosConnectionString);
        const cosmosClient = new CosmosClient({
            endpoint,
            key,
            userAgentSuffix: USER_AGENT_SUFFIX
        });
        return new AzureCosmosNoSqlChatStore({
            ...config,
            cosmosClient
        });
    }
    /**
   * Static method for creating an instance using a account endpoint and key.
   * If no endpoint and key  is provided, it will attempt to use the env variable `AZURE_COSMOSDB_NOSQL_ACCOUNT_ENDPOINT` as enpoint and `AZURE_COSMOSDB_NOSQL_ACCOUNT_KEY` as key.
   * @returns Instance of AzureCosmosNoSqlKVStore
   */ static fromAccountAndKey(config = {}) {
        const cosmosEndpoint = config.endpoint || getEnv("AZURE_COSMOSDB_NOSQL_ACCOUNT_ENDPOINT");
        const cosmosKey = config.key || getEnv("AZURE_COSMOSDB_NOSQL_ACCOUNT_KEY");
        if (!cosmosEndpoint || !cosmosKey) {
            throw new Error("Azure CosmosDB account endpoint and key must be provided");
        }
        const cosmosClient = new CosmosClient({
            endpoint: cosmosEndpoint,
            key: cosmosKey,
            userAgentSuffix: USER_AGENT_SUFFIX
        });
        return new AzureCosmosNoSqlChatStore({
            ...config,
            cosmosClient
        });
    }
    /**
   * Static method for creating an instance using AAD token.
   * If no endpoint and credentials are provided, it will attempt to use the env variable `AZURE_COSMOSDB_NOSQL_ACCOUNT_ENDPOINT` as endpoint and use DefaultAzureCredential() as credentials.
   * @returns Instance of AzureCosmosNoSqlKVStore
   */ static fromAadToken(config = {}) {
        const cosmosEndpoint = config.endpoint || getEnv("AZURE_COSMOSDB_NOSQL_CONNECTION_STRING");
        if (!cosmosEndpoint) {
            throw new Error("Azure CosmosDB account endpoint must be provided");
        }
        const credentials = config.credential ?? new DefaultAzureCredential();
        const cosmosClient = new CosmosClient({
            endpoint: cosmosEndpoint,
            aadCredentials: credentials,
            userAgentSuffix: USER_AGENT_SUFFIX
        });
        return new AzureCosmosNoSqlChatStore({
            ...config,
            cosmosClient
        });
    }
    convertToChatMessage(// eslint-disable-next-line @typescript-eslint/no-explicit-any
    message) {
        return {
            content: message.content,
            role: message.role,
            options: message.options
        };
    }
    convertToCosmosMessage(message) {
        return {
            content: message.content,
            role: message.role,
            options: message.options
        };
    }
    /**
   * Set messages for a given key.
   */ async setMessages(key, messages) {
        await this.initialize();
        const inputMessages = messages.map(this.convertToCosmosMessage);
        await this.container.items.upsert({
            id: key,
            messages: inputMessages,
            userId: this.userId
        });
    }
    /**
   * Get messages for a given key.
   */ async getMessages(key) {
        await this.initialize();
        const res = await this.container.item(key, this.userId).read();
        const messageHistory = res?.resource?.messages ?? [];
        const result = messageHistory.map(this.convertToChatMessage);
        return result;
    }
    /**
   * Add a message for a given key.
   */ async addMessage(key, message, idx) {
        await this.initialize();
        const res = await this.container.item(key, this.userId).read();
        const messageHistory = res?.resource?.messages ?? [];
        if (idx === undefined) {
            messageHistory.push(this.convertToCosmosMessage(message));
        } else {
            messageHistory.splice(idx, 0, this.convertToCosmosMessage(message));
        }
        await this.setMessages(key, messageHistory);
    }
    /**
   * Deletes all messages for a given key.
   */ async deleteMessages(key) {
        await this.initialize();
        try {
            await this.container.item(key, this.userId).delete();
        // eslint-disable-next-line no-empty
        } catch (e) {}
    }
    /**
   * Deletes one message at idx index for a given key.
   */ async deleteMessage(key, idx) {
        await this.initialize();
        const res = await this.container.item(key, this.userId).read();
        const messageHistory = res?.resource?.messages ?? [];
        if (idx >= 0 && idx < messageHistory.length) {
            messageHistory.splice(idx, 1);
            await this.setMessages(key, messageHistory);
        }
    }
    /**
   * Get all keys.
   */ async getKeys() {
        await this.initialize();
        const result = await this.container.items.query("Select c.id from c").fetchAll();
        const keys = result.resources.map((res)=>res.id);
        function* keyGenerator() {
            for (const key of keys){
                yield key;
            }
        }
        return keyGenerator();
    }
}
