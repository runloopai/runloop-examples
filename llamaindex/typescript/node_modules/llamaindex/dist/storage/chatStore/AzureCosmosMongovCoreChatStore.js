/* eslint-disable @typescript-eslint/no-explicit-any */ import { BaseChatStore } from "@llamaindex/core/storage/chat-store";
const DEFAULT_CHAT_DATABASE = "ChatStoreDB";
const DEFAULT_CHAT_Collection = "ChatStoreCollection";
export class AzureCosmosVCoreChatStore extends BaseChatStore {
    mongoClient;
    dbName;
    collectionName;
    collection;
    /**
   * Create a new AzureCosmosVCoreChatStore instance.
   */ constructor({ mongoClient, dbName = DEFAULT_CHAT_DATABASE, collectionName = DEFAULT_CHAT_Collection }){
        super();
        if (!mongoClient) {
            throw new Error("MongoClient is required for AzureCosmosVCoreChatStore initialization");
        }
        this.mongoClient = mongoClient;
        this.dbName = dbName;
        this.collectionName = collectionName;
    }
    static fromMongoClient(mongoClient, dbName = DEFAULT_CHAT_DATABASE, collectionName = DEFAULT_CHAT_Collection) {
        return new AzureCosmosVCoreChatStore({
            mongoClient,
            dbName,
            collectionName
        });
    }
    client() {
        return this.mongoClient;
    }
    convertToChatMessage(message) {
        return {
            content: message.content,
            role: message.role,
            options: message.options
        };
    }
    convertTovCoreMessage(message) {
        return {
            content: message.content,
            role: message.role,
            options: message.options
        };
    }
    async ensureCollection() {
        if (!this.collection) {
            this.collection = this.mongoClient.db(this.dbName).collection(this.collectionName);
        }
        return this.collection;
    }
    /**
   * Set messages for a given key.
   */ async setMessages(key, messages) {
        const collection = await this.ensureCollection();
        const inputMessages = messages.map(this.convertTovCoreMessage);
        await collection.updateOne({
            id: key
        }, {
            $set: {
                messages: inputMessages
            }
        }, {
            upsert: true
        });
    }
    /**
   * Get messages for a given key.
   */ async getMessages(key) {
        const collection = await this.ensureCollection();
        const res = await collection.findOne({
            id: key
        });
        const messageHistory = res?.messages ?? [];
        const result = messageHistory.map(this.convertToChatMessage);
        return result;
    }
    /**
   * Add a message for a given key.
   */ async addMessage(key, message, idx) {
        const collection = await this.ensureCollection();
        const res = await this.getMessages(key);
        const messageHistory = res.map(this.convertTovCoreMessage) ?? [];
        messageHistory.splice(idx ?? messageHistory.length, 0, this.convertTovCoreMessage(message));
        await collection.updateOne({
            id: key
        }, {
            $set: {
                messages: messageHistory
            }
        }, {
            upsert: true
        });
    }
    /**
   * Deletes all messages for a given key.
   */ async deleteMessages(key) {
        const collection = await this.ensureCollection();
        try {
            await collection.deleteOne({
                id: key
            });
        // eslint-disable-next-line no-empty
        } catch (e) {}
    }
    /**
   * Deletes one message at idx index for a given key.
   */ async deleteMessage(key, idx) {
        // const collection = await this.ensureCollection();
        const messageHistory = await this.getMessages(key);
        if (idx >= 0 && idx < messageHistory.length) {
            messageHistory.splice(idx, 1);
            await this.setMessages(key, messageHistory);
        }
    }
    /**
   * Get all keys.
   */ async getKeys() {
        const collection = await this.ensureCollection();
        const keys = await collection.distinct("id");
        function* keyGenerator() {
            for (const key of keys){
                yield key;
            }
        }
        return keyGenerator();
    }
}
