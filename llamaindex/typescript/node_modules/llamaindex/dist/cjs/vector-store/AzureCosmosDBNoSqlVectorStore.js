"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AzureCosmosDBNoSqlVectorStore", {
    enumerable: true,
    get: function() {
        return AzureCosmosDBNoSqlVectorStore;
    }
});
const _cosmos = require("@azure/cosmos");
const _identity = require("@azure/identity");
const _schema = require("@llamaindex/core/schema");
const _env = require("@llamaindex/env");
const _utils = require("./utils.js");
const _types = require("./types.js");
const USER_AGENT_SUFFIX = "llamaindex-cdbnosql-vectorstore-javascript";
const DEFAULT_VECTOR_EMBEDDING_POLICY = {
    vectorEmbeddings: [
        {
            path: "/embedding",
            dataType: _cosmos.VectorEmbeddingDataType.Float32,
            distanceFunction: _cosmos.VectorEmbeddingDistanceFunction.Cosine,
            dimensions: 1536
        }
    ]
};
const DEFAULT_VECTOR_INDEXING_POLICY = [
    {
        path: "/embedding",
        type: _cosmos.VectorIndexType.QuantizedFlat
    }
];
function parseConnectionString(connectionString) {
    const parts = connectionString.split(";");
    let endpoint = "";
    let accountKey = "";
    parts.forEach((part)=>{
        const [key, value] = part.split("=");
        if (key && key.trim() === "AccountEndpoint") {
            endpoint = value?.trim() ?? "";
        } else if ((key ?? "").trim() === "AccountKey") {
            accountKey = value?.trim() ?? "";
        }
    });
    if (!endpoint || !accountKey) {
        throw new Error("Invalid connection string: missing AccountEndpoint or AccountKey.");
    }
    return {
        endpoint,
        key: accountKey
    };
}
/**
 * utility function to build the query string for the CosmosDB query
 */ function queryBuilder(options) {
    let initialQuery = "SELECT TOP @k c[@id] as id, c[@text] as text, c[@metadata] as metadata";
    if (options.includeVectorDistance !== false) {
        initialQuery += `, VectorDistance(c[@embeddingKey],@embedding) AS SimilarityScore`;
    }
    initialQuery += ` FROM c`;
    if (options.whereClause) {
        initialQuery += ` WHERE ${options.whereClause}`;
    }
    initialQuery += ` ORDER BY VectorDistance(c[@embeddingKey],@embedding)`;
    return initialQuery;
}
class AzureCosmosDBNoSqlVectorStore extends _types.BaseVectorStore {
    storesText = true;
    initPromise;
    container;
    /**
   * The CosmosDB client. This is either passed in or created.
   */ cosmosClient;
    /**
   * The key to use for the text field in the CosmosDB container.
   * Default: "text"
   */ textKey;
    flatMetadata = true;
    /**
   * The key to use for the id field in the CosmosDB container.
   * Default: "id"
   */ idKey;
    /**
   * The key to use for the metadata field in the CosmosDB container.
   * Default: "metadata"
   */ metadataKey;
    /**
   * The key to use for the vector embedding field in the CosmosDB container.
   * Default: "embedding"
   */ embeddingKey;
    initialize;
    client() {
        return this.cosmosClient;
    }
    constructor(dbConfig){
        super(dbConfig);
        if (!dbConfig.client) {
            throw new Error("CosmosClient is required for AzureCosmosDBNoSQLVectorStore initialization");
        }
        this.cosmosClient = dbConfig.client;
        const databaseName = dbConfig.databaseName ?? "vectorSearchDB";
        const containerName = dbConfig.containerName ?? "vectorSearchContainer";
        this.idKey = dbConfig.idKey ?? "id";
        this.textKey = dbConfig.textKey ?? "text";
        this.flatMetadata = dbConfig.flatMetadata ?? true;
        this.metadataKey = dbConfig.metadataKey ?? "metadata";
        const vectorEmbeddingPolicy = dbConfig.vectorEmbeddingPolicy ?? DEFAULT_VECTOR_EMBEDDING_POLICY;
        const indexingPolicy = dbConfig.indexingPolicy ?? {
            vectorIndexes: DEFAULT_VECTOR_INDEXING_POLICY
        };
        this.embeddingKey = vectorEmbeddingPolicy.vectorEmbeddings?.[0]?.path?.slice(1) ?? "";
        if (!this.embeddingKey) {
            throw new Error("AzureCosmosDBNoSQLVectorStore requires a valid vectorEmbeddings path");
        }
        // Deferring initialization to the first call to `initialize`
        this.initialize = ()=>{
            if (this.initPromise === undefined) {
                this.initPromise = this.init(this.cosmosClient, databaseName, containerName, {
                    vectorEmbeddingPolicy,
                    indexingPolicy,
                    createContainerOptions: dbConfig.createContainerOptions,
                    createDatabaseOptions: dbConfig.createDatabaseOptions
                }).catch((error)=>{
                    console.error("Error during AzureCosmosDBNoSQLVectorStore initialization", error);
                });
            }
            return this.initPromise;
        };
    }
    /**
   * Static method for creating an instance using a connection string.
   * If no connection string is provided, it will attempt to use the env variable `AZURE_COSMOSDB_NOSQL_CONNECTION_STRING` as connection string.
   * @returns Instance of AzureCosmosDBNoSqlVectorStore
   */ static fromConnectionString(config = {}) {
        const cosmosConnectionString = config.connectionString || (0, _env.getEnv)("AZURE_COSMOSDB_NOSQL_CONNECTION_STRING");
        if (!cosmosConnectionString) {
            throw new Error("Azure CosmosDB connection string must be provided");
        }
        const { endpoint, key } = parseConnectionString(cosmosConnectionString);
        const client = new _cosmos.CosmosClient({
            endpoint,
            key,
            userAgentSuffix: USER_AGENT_SUFFIX
        });
        return new AzureCosmosDBNoSqlVectorStore({
            ...config,
            client
        });
    }
    /**
   * Static method for creating an instance using a account endpoint and key.
   * If no endpoint and key  is provided, it will attempt to use the env variable `AZURE_COSMOSDB_NOSQL_ACCOUNT_ENDPOINT` as enpoint and `AZURE_COSMOSDB_NOSQL_ACCOUNT_KEY` as key.
   * @returns Instance of AzureCosmosDBNoSqlVectorStore
   */ static fromAccountAndKey(config = {}) {
        const cosmosEndpoint = config.endpoint || (0, _env.getEnv)("AZURE_COSMOSDB_NOSQL_ENDPOINT");
        const cosmosKey = config.key || (0, _env.getEnv)("AZURE_COSMOSDB_NOSQL_KEY");
        if (!cosmosEndpoint || !cosmosKey) {
            throw new Error("Azure CosmosDB account endpoint and key must be provided");
        }
        const client = new _cosmos.CosmosClient({
            endpoint: cosmosEndpoint,
            key: cosmosKey,
            userAgentSuffix: USER_AGENT_SUFFIX
        });
        return new AzureCosmosDBNoSqlVectorStore({
            ...config,
            client
        });
    }
    /**
   * Static method for creating an instance using account endpoint and managed identity.
   * If no endpoint and credentials are provided, it will attempt to use the env variable `AZURE_COSMOSDB_NOSQL_ACCOUNT_ENDPOINT` as endpoint and use DefaultAzureCredential() as credentials.
   * @returns Instance of AzureCosmosDBNoSqlVectorStore
   */ static fromUriAndManagedIdentity(config = {}) {
        const cosmosEndpoint = config.endpoint || (0, _env.getEnv)("AZURE_COSMOSDB_NOSQL_ACCOUNT_ENDPOINT");
        if (!cosmosEndpoint) {
            throw new Error("Azure CosmosDB account endpoint must be provided");
        }
        const credentials = config.credential ?? new _identity.DefaultAzureCredential();
        const client = new _cosmos.CosmosClient({
            endpoint: cosmosEndpoint,
            aadCredentials: credentials,
            userAgentSuffix: USER_AGENT_SUFFIX
        });
        return new AzureCosmosDBNoSqlVectorStore({
            ...config,
            client
        });
    }
    /**
   * Adds document to the CosmosDB container.
   *
   * @returns an array of document ids which were added
   */ async add(nodes) {
        await this.initialize();
        if (!nodes || nodes.length === 0) {
            return [];
        }
        const docs = nodes.map((node)=>{
            const metadata = (0, _utils.nodeToMetadata)(node, true, this.textKey, this.flatMetadata);
            return {
                [this.idKey]: node.id_,
                [this.embeddingKey]: node.getEmbedding(),
                [this.textKey]: node.getContent(_schema.MetadataMode.NONE) || "",
                [this.metadataKey]: metadata
            };
        });
        const ids = [];
        const results = await Promise.allSettled(docs.map((doc)=>this.container.items.create(doc)));
        for (const result of results){
            if (result.status === "fulfilled") {
                ids.push(result.value.resource?.id ?? "");
            } else {
                ids.push("error: could not create item");
            }
        }
        return ids;
    }
    /**
   * Delete a document from the CosmosDB container.
   *
   * @param refDocId - The id of the document to delete
   * @param deleteOptions - Any options to pass to the container.item.delete function
   * @returns Promise that resolves if the delete query did not throw an error.
   */ async delete(refDocId, deleteOptions) {
        await this.initialize();
        await this.container.item(refDocId).delete(deleteOptions);
    }
    /**
   * Performs a vector similarity search query in the CosmosDB container.
   *
   * @param query VectorStoreQuery
   * @returns List of nodes along with similarityScore
   */ async query(query, options = {}) {
        await this.initialize();
        if (!query.queryEmbedding || query.queryEmbedding.length === 0) {
            throw new Error("queryEmbedding is required for AzureCosmosDBNoSqlVectorStore query");
        }
        const params = {
            vector: query.queryEmbedding,
            k: query.similarityTopK
        };
        const builtQuery = queryBuilder(options);
        const nodes = [];
        const ids = [];
        const similarities = [];
        const queryResults = await this.container.items.query({
            query: builtQuery,
            parameters: [
                {
                    name: "@k",
                    value: params.k
                },
                {
                    name: "@id",
                    value: this.idKey
                },
                {
                    name: "@text",
                    value: this.textKey
                },
                {
                    name: "@metadata",
                    value: this.metadataKey
                },
                {
                    name: "@embedding",
                    value: params.vector
                },
                {
                    name: "@embeddingKey",
                    value: this.embeddingKey
                }
            ]
        }).fetchAll();
        for (const item of queryResults.resources){
            const node = (0, _utils.metadataDictToNode)(item["metadata"], {
                fallback: {
                    id_: item["id"],
                    text: item["text"],
                    ...item["metadata"]
                }
            });
            node.setContent(item["text"]);
            const nodeId = item["id"];
            const nodeScore = item["SimilarityScore"];
            nodes.push(node);
            ids.push(nodeId);
            similarities.push(nodeScore);
        }
        const result = {
            nodes,
            similarities,
            ids
        };
        return result;
    }
    /**
   * Initialize the CosmosDB container.
   */ async init(client, databaseName, containerName, initOptions) {
        const { database } = await client.databases.createIfNotExists({
            ...initOptions?.createDatabaseOptions ?? {},
            id: databaseName
        });
        const { container } = await database.containers.createIfNotExists({
            ...initOptions?.createContainerOptions ?? {
                partitionKey: {
                    paths: [
                        "/id"
                    ]
                }
            },
            indexingPolicy: initOptions.indexingPolicy || {
                vectorIndexes: DEFAULT_VECTOR_INDEXING_POLICY
            },
            vectorEmbeddingPolicy: initOptions?.vectorEmbeddingPolicy || DEFAULT_VECTOR_EMBEDDING_POLICY,
            id: containerName
        });
        this.container = container;
    }
}
