"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AzureAISearchVectorStore: function() {
        return AzureAISearchVectorStore;
    },
    IndexManagement: function() {
        return IndexManagement;
    },
    MetadataIndexFieldType: function() {
        return MetadataIndexFieldType;
    }
});
const _searchdocuments = require("@azure/search-documents");
const _identity = require("@azure/identity");
const _schema = require("@llamaindex/core/schema");
const _env = require("@llamaindex/env");
const _types = require("../types.js");
const _utils = require("../utils.js");
const _AzureAISearchVectorStoreConfig = require("./AzureAISearchVectorStoreConfig.js");
const _AzureQueryResultSearch = require("./AzureQueryResultSearch.js");
var IndexManagement = /*#__PURE__*/ function(IndexManagement) {
    IndexManagement["NO_VALIDATION"] = "NoValidation";
    IndexManagement["VALIDATE_INDEX"] = "ValidateIndex";
    IndexManagement["CREATE_IF_NOT_EXISTS"] = "CreateIfNotExists";
    return IndexManagement;
}({});
var MetadataIndexFieldType = /*#__PURE__*/ function(MetadataIndexFieldType) {
    MetadataIndexFieldType["STRING"] = "Edm.String";
    MetadataIndexFieldType["BOOLEAN"] = "Edm.Boolean";
    MetadataIndexFieldType["INT32"] = "Edm.Int32";
    MetadataIndexFieldType["INT64"] = "Edm.Int64";
    MetadataIndexFieldType["DOUBLE"] = "Edm.Double";
    MetadataIndexFieldType["COLLECTION"] = "Collection(Edm.String)";
    return MetadataIndexFieldType;
}({});
const createSearchRequest = (fieldMapping, filterStr, batchSize, offset)=>{
    return {
        filter: filterStr,
        top: batchSize,
        skip: offset,
        select: Object.keys(fieldMapping)
    };
};
class AzureAISearchVectorStore extends _types.BaseVectorStore {
    storesText = true;
    _searchClient;
    #languageAnalyzer;
    #embeddingDimensionality;
    #vectorProfileName;
    #compressionType;
    _indexClient;
    #indexManagement;
    #indexName;
    #fieldMapping;
    #metadataToIndexFieldMap = new Map();
    flatMetadata = true;
    #idFieldKey;
    #chunkFieldKey;
    #embeddingFieldKey;
    #docIdFieldKey;
    #metadataStringFieldKey;
    #serviceApiVersion;
    #indexMapping;
    #hiddenFiledKeys;
    constructor(options){
        super(options);
        // set default values
        options.vectorAlgorithmType ||= _searchdocuments.KnownVectorSearchAlgorithmKind.ExhaustiveKnn;
        options.languageAnalyzer ||= _searchdocuments.KnownAnalyzerNames.EnLucene;
        options.indexManagement ||= "NoValidation";
        options.embeddingDimensionality ||= 1536;
        options.serviceApiVersion ||= (0, _env.getEnv)("AZURE_SEARCH_API_VERSION");
        options.hiddenFieldKeys ||= [];
        // set props
        this.#serviceApiVersion = options.serviceApiVersion || _AzureAISearchVectorStoreConfig.AzureAISearchVectorStoreConfig.DEFAULT_AZURE_API_VERSION;
        this.#languageAnalyzer = options.languageAnalyzer;
        this.#compressionType = options.compressionType;
        this.#embeddingDimensionality = options.embeddingDimensionality;
        this.#indexManagement = options.indexManagement;
        this.#indexName = options.indexName;
        this.#idFieldKey = options.idFieldKey;
        this.#docIdFieldKey = options.docIdFieldKey;
        this.#chunkFieldKey = options.chunkFieldKey;
        this.#embeddingFieldKey = options.embeddingFieldKey;
        this.#metadataStringFieldKey = options.metadataStringFieldKey;
        this.#hiddenFiledKeys = options.hiddenFieldKeys;
        this.#indexMapping = options.indexMapping || this.#defaultIndexMapping;
        // Default field mapping
        this.#fieldMapping = {
            ["id"]: options.idFieldKey,
            ["doc_id"]: options.docIdFieldKey,
            ["chunk"]: options.chunkFieldKey,
            ["embedding"]: options.embeddingFieldKey,
            ["metadata"]: options.metadataStringFieldKey
        };
        this.#setVectorProfileName(options.vectorAlgorithmType);
        this.#valideSearchOrIndexClient(options);
        // Normalizing metadata to index fields
        this.#metadataToIndexFieldMap = this.#normalizeMetadataToIndexFields(options.filterableMetadataFieldKeys);
    }
    // private
    #normalizeMetadataToIndexFields(filterableMetadataFieldKeys) {
        const indexFieldSpec = new Map();
        if (Array.isArray(filterableMetadataFieldKeys)) {
            // if filterableMetadataFieldKeys is an array, use the field name as the index field name
            // eg. [
            //  "author",
            //  "theme",
            //  "director"
            // ] => {
            //  "author": ["author", "Edm.String"],
            //  "theme": ["theme", "Edm.String"],
            //  "director": ["director", "Edm.String"]
            // }
            filterableMetadataFieldKeys.forEach((field)=>{
                indexFieldSpec.set(field, [
                    field,
                    "Edm.String"
                ]);
            });
        } else if (typeof filterableMetadataFieldKeys === "object") {
            // if filterableMetadataFieldKeys is an object, use the key as the index field name
            // and the value as the metadata field name
            // eg. {
            //  "author": "author",
            //  "theme": ["topic", MetadataIndexFieldType.STRING],
            //  "director": "director"
            // } => {
            //  "author": ["author", "Edm.String"],
            //  "theme": ["topic", "Edm.String"],
            //  "director": ["director", "Edm.String"]
            // }
            // we also support specifying the metadata field type
            // MetadataIndexFieldType.INT32 --> "Edm.Int32"
            // MetadataIndexFieldType.INT64 --> "Edm.Int64"
            // MetadataIndexFieldType.DOUBLE --> "Edm.Double"
            // MetadataIndexFieldType.BOOLEAN --> "Edm.Boolean"
            // MetadataIndexFieldType.COLLECTION --> "Collection(Edm.String)"
            Object.entries(filterableMetadataFieldKeys).forEach(([k, v])=>{
                if (Array.isArray(v)) {
                    indexFieldSpec.set(k, [
                        v[0],
                        v[1]
                    ]);
                } else {
                    switch(v){
                        case "Edm.String":
                            indexFieldSpec.set(k, [
                                v,
                                "Edm.String"
                            ]);
                            break;
                        case "Edm.Int32":
                            indexFieldSpec.set(k, [
                                v,
                                "Edm.Int32"
                            ]);
                            break;
                        case "Edm.Int64":
                            indexFieldSpec.set(k, [
                                v,
                                "Edm.Int64"
                            ]);
                            break;
                        case "Edm.Double":
                            indexFieldSpec.set(k, [
                                v,
                                "Edm.Double"
                            ]);
                            break;
                        case "Edm.Boolean":
                            indexFieldSpec.set(k, [
                                v,
                                "Edm.Boolean"
                            ]);
                            break;
                        case "Collection(Edm.String)":
                            indexFieldSpec.set(k, [
                                v,
                                "Collection(Edm.String)"
                            ]);
                            break;
                        default:
                            // Index field name and metadata field name may differ
                            // Use String as the default index field type
                            indexFieldSpec.set(k, [
                                v,
                                "Edm.String"
                            ]);
                            break;
                    }
                }
            });
        }
        return indexFieldSpec;
    }
    #defaultIndexMapping(node, metadata) {
        // include metadata fields in the index document
        const filterableMetadata = {};
        for (const [fieldName, _fieldType] of this.#metadataToIndexFieldMap.values()){
            filterableMetadata[fieldName] = metadata[fieldName];
        }
        return {
            [this.#embeddingFieldKey]: node.getEmbedding(),
            [this.#idFieldKey]: node.id_,
            [this.#docIdFieldKey]: node.id_,
            [this.#chunkFieldKey]: node.getContent(_schema.MetadataMode.NONE),
            [this.#metadataStringFieldKey]: JSON.stringify(metadata),
            ...filterableMetadata
        };
    }
    #setVectorProfileName(vectorAlgorithmType) {
        if (vectorAlgorithmType === _searchdocuments.KnownVectorSearchAlgorithmKind.ExhaustiveKnn) {
            this.#vectorProfileName = "myExhaustiveKnnProfile";
        } else if (vectorAlgorithmType === _searchdocuments.KnownVectorSearchAlgorithmKind.Hnsw) {
            this.#vectorProfileName = "myHnswProfile";
        } else {
            throw new Error("Only 'exhaustiveKnn' and 'hnsw' are supported for vectorAlgorithmType");
        }
    }
    /**
   * Create a list of index fields for storing metadata values.
   * @returns List of index fields for storing metadata values
   */ #createMetadataIndexFields() {
        const indexFields = [];
        for (const [fieldName, fieldType] of this.#metadataToIndexFieldMap.values()){
            if (this.#fieldMapping[fieldName]) {
                _env.consoleLogger.log(`Skipping metadata field ${fieldName} as it is already mapped to an index field`);
                continue;
            }
            let indexFieldType;
            switch(fieldType){
                case "Edm.String":
                    indexFieldType = _searchdocuments.KnownSearchFieldDataType.String;
                    break;
                case "Edm.Int32":
                    indexFieldType = _searchdocuments.KnownSearchFieldDataType.Int32;
                    break;
                case "Edm.Int64":
                    indexFieldType = _searchdocuments.KnownSearchFieldDataType.Int64;
                    break;
                case "Edm.Double":
                    indexFieldType = _searchdocuments.KnownSearchFieldDataType.Double;
                    break;
                case "Edm.Boolean":
                    indexFieldType = _searchdocuments.KnownSearchFieldDataType.Boolean;
                    break;
                case "Collection(Edm.String)":
                    indexFieldType = `Collection(${_searchdocuments.KnownSearchFieldDataType.String})`;
                    break;
                default:
                    throw new Error(`Unsupported field type: ${fieldType}`);
            }
            indexFields.push({
                name: fieldName,
                type: indexFieldType,
                filterable: true
            });
        }
        return indexFields;
    }
    // index management
    async #indexExists(indexName) {
        if (!indexName) {
            throw new Error(`options.indexName is not valid`);
        }
        const availableIndexNames = await this._indexClient?.listIndexesNames();
        if (!availableIndexNames) {
            return false;
        }
        let listOfIndexNames = await availableIndexNames.next();
        const indexNames = [];
        while(!listOfIndexNames.done){
            indexNames.push(listOfIndexNames.value);
            listOfIndexNames = await availableIndexNames.next();
        }
        return indexNames.includes(indexName);
    }
    async #createIndexIfNotExists(indexName) {
        const indexExists = await this.#indexExists(indexName);
        if (!indexExists) {
            _env.consoleLogger.log(`Index ${indexName} does not exist in Azure AI Search, creating index`);
            await this.#createIndex(indexName);
        }
    }
    /**
   * Creates a default index based on the supplied index name, key field names and
   * metadata filtering keys.
   * @param indexName The name of the index to create
   */ async #createIndex(indexName) {
        _env.consoleLogger.log(`Configuring ${indexName} fields for Azure AI Search`);
        const fields = [
            {
                name: this.#fieldMapping["id"],
                type: _searchdocuments.KnownSearchFieldDataType.String,
                hidden: this.#hiddenFiledKeys?.includes(this.#fieldMapping["id"]),
                key: true,
                filterable: true,
                retrievable: true,
                searchable: true
            },
            {
                name: this.#fieldMapping["chunk"],
                type: _searchdocuments.KnownSearchFieldDataType.String,
                hidden: this.#hiddenFiledKeys?.includes(this.#fieldMapping["chunk"]),
                analyzerName: this.#languageAnalyzer,
                searchable: true
            },
            {
                name: this.#fieldMapping["embedding"],
                type: `Collection(${_searchdocuments.KnownSearchFieldDataType.Single})`,
                vectorSearchDimensions: this.#embeddingDimensionality,
                vectorSearchProfileName: this.#vectorProfileName,
                hidden: this.#hiddenFiledKeys?.includes(this.#fieldMapping["embedding"]),
                searchable: true
            },
            {
                name: this.#fieldMapping["metadata"],
                hidden: this.#hiddenFiledKeys?.includes(this.#fieldMapping["metadata"]),
                type: _searchdocuments.KnownSearchFieldDataType.String
            },
            {
                name: this.#fieldMapping["doc_id"],
                type: _searchdocuments.KnownSearchFieldDataType.String,
                hidden: this.#hiddenFiledKeys?.includes(this.#fieldMapping["doc_id"]),
                filterable: true,
                retrievable: true,
                searchable: true
            }
        ];
        _env.consoleLogger.log(`Configuring ${indexName} metadata fields`);
        const metadataIndexFields = this.#createMetadataIndexFields();
        fields.push(...metadataIndexFields);
        _env.consoleLogger.log(`Configuring ${indexName} vector search`);
        const compressions = this.#getCompressions();
        _env.consoleLogger.log(`Configuring ${indexName} vector search with ${this.#compressionType} compression`);
        const vectorSearch = {
            algorithms: [
                {
                    name: _AzureAISearchVectorStoreConfig.AzureAISearchVectorStoreConfig.ALGORITHM_HNSW_NAME,
                    kind: _searchdocuments.KnownVectorSearchAlgorithmKind.Hnsw,
                    parameters: {
                        m: 4,
                        efConstruction: 400,
                        efSearch: 500,
                        metric: _searchdocuments.KnownVectorSearchAlgorithmMetric.Cosine
                    }
                },
                {
                    name: _AzureAISearchVectorStoreConfig.AzureAISearchVectorStoreConfig.ALGORITHM_EXHAUSTIVE_KNN_NAME,
                    kind: _searchdocuments.KnownVectorSearchAlgorithmKind.ExhaustiveKnn,
                    parameters: {
                        metric: _searchdocuments.KnownVectorSearchAlgorithmMetric.Cosine
                    }
                }
            ],
            compressions,
            profiles: [
                {
                    name: _AzureAISearchVectorStoreConfig.AzureAISearchVectorStoreConfig.PROFILE_HNSW_NAME,
                    algorithmConfigurationName: _AzureAISearchVectorStoreConfig.AzureAISearchVectorStoreConfig.ALGORITHM_HNSW_NAME,
                    compressionName: compressions?.[0]?.compressionName
                },
                {
                    name: _AzureAISearchVectorStoreConfig.AzureAISearchVectorStoreConfig.PROFILE_EXHAUSTIVE_KNN_NAME,
                    algorithmConfigurationName: _AzureAISearchVectorStoreConfig.AzureAISearchVectorStoreConfig.ALGORITHM_EXHAUSTIVE_KNN_NAME
                }
            ]
        };
        _env.consoleLogger.log(`Configuring ${indexName} semantic search`);
        const semanticConfig = {
            name: _AzureAISearchVectorStoreConfig.AzureAISearchVectorStoreConfig.SEMANTIC_CONFIG_NAME,
            prioritizedFields: {
                contentFields: [
                    {
                        name: this.#fieldMapping["chunk"]
                    }
                ],
                keywordsFields: [
                    {
                        name: this.#fieldMapping["metadata"]
                    }
                ],
                titleField: {
                    name: this.#fieldMapping["id"]
                }
            }
        };
        const semanticSearch = {
            configurations: [
                semanticConfig
            ]
        };
        const index = {
            name: indexName,
            fields: fields,
            vectorSearch: vectorSearch,
            semanticSearch: semanticSearch
        };
        _env.consoleLogger.log(`Creating ${indexName} search index with configuration:`);
        _env.consoleLogger.log({
            index
        });
        await this._indexClient?.createIndex(index);
    }
    /**
   * Get the compressions for the vector search
   * @returns Array of compressions. See {@link VectorSearchCompression}
   */ #getCompressions() {
        const compressions = [];
        if (this.#compressionType === _searchdocuments.KnownVectorSearchCompressionKind.BinaryQuantization) {
            compressions.push({
                compressionName: _AzureAISearchVectorStoreConfig.AzureAISearchVectorStoreConfig.COMPRESSION_TYPE_BINARY,
                kind: _searchdocuments.KnownVectorSearchCompressionKind.BinaryQuantization
            });
        } else if (this.#compressionType === _searchdocuments.KnownVectorSearchCompressionKind.ScalarQuantization) {
            compressions.push({
                compressionName: _AzureAISearchVectorStoreConfig.AzureAISearchVectorStoreConfig.COMPRESSION_TYPE_SCALAR,
                kind: _searchdocuments.KnownVectorSearchCompressionKind.ScalarQuantization
            });
        }
        return compressions;
    }
    #valideSearchOrIndexClient(options) {
        if (options.searchClient) {
            if (options.searchClient instanceof _searchdocuments.SearchClient) {
                _env.consoleLogger.log("Using provided Azure SearchClient");
                this._searchClient = options.searchClient;
                if (options.indexName) {
                    throw new Error("options.indexName cannot be supplied if using options.searchClient");
                }
            } else {
                throw new Error("options.searchClient must be an instance of SearchClient");
            }
        } else {
            this.createSearchClient(options);
        }
        if (options.indexClient) {
            if (options.indexClient instanceof _searchdocuments.SearchIndexClient) {
                if (!options.indexName) {
                    throw new Error("options.indexName must be supplied if using options.indexClient");
                }
                this._indexClient = options.indexClient;
            } else {
                throw new Error("options.indexClient must be an instance of SearchIndexClient");
            }
        } else {
            this.createSearchIndexClient(options);
        }
        if (options.indexManagement === "CreateIfNotExists" && !this._indexClient) {
            throw new Error("IndexManagement.CREATE_IF_NOT_EXISTS requires options.indexClient");
        }
        if (!this._searchClient && !this._indexClient) {
            throw new Error("Either options.searchClient or options.indexClient must be supplied");
        }
    }
    #buildCredentials(options) {
        let { credential: credential, key, endpoint, indexName } = options;
        // validate and use credential
        if (credential) {
            // if credential are provided, ensure they are an instance of valid credential instances
            if (!(credential instanceof _searchdocuments.AzureKeyCredential || credential instanceof _identity.DefaultAzureCredential || credential instanceof _identity.ManagedIdentityCredential)) {
                throw new Error("options.credential must be an instance of AzureKeyCredential or DefaultAzureCredential or ManagedIdentityCredential");
            }
        } else {
            key ??= (0, _env.getEnv)("AZURE_AI_SEARCH_KEY");
            if (key) {
                _env.consoleLogger.log("Using provided Azure Search key");
                credential = new _searchdocuments.AzureKeyCredential(key);
            } else {
                const clientId = (0, _env.getEnv)("AZURE_CLIENT_ID");
                if (clientId) {
                    _env.consoleLogger.log("Using Azure Managed identity");
                    credential = new _identity.ManagedIdentityCredential(clientId);
                } else {
                    // if key wasn't provided, try using DefaultAzureCredential
                    _env.consoleLogger.log("Using Default Azure Credential");
                    credential = new _identity.DefaultAzureCredential();
                }
            }
        }
        // validate and use endpoint
        endpoint ??= (0, _env.getEnv)("AZURE_AI_SEARCH_ENDPOINT");
        if (!endpoint) {
            throw new Error("options.endpoint must be provided or set as an environment variable: AZURE_AI_SEARCH_ENDPOINT");
        } else {
            // check if enpoint is a valid URL
            try {
                new URL(endpoint);
            } catch (error) {
                throw new Error(`options.endpoint must be a valid URL.`);
            }
        }
        // validate and use indexName
        if (!indexName) {
            if (this._searchClient) {
                indexName = this._searchClient.indexName;
            } else {
                throw new Error("options.indexName must be provided");
            }
        }
        return {
            credential,
            endpoint,
            indexName
        };
    }
    createSearchIndexClient(options) {
        const { credential, endpoint } = this.#buildCredentials(options);
        this._indexClient = new _searchdocuments.SearchIndexClient(endpoint, credential, {
            serviceVersion: this.#serviceApiVersion,
            userAgentOptions: {
                userAgentPrefix: options.userAgent ?? _AzureAISearchVectorStoreConfig.AzureAISearchVectorStoreConfig.DEFAULT_USER_AGENT_PREFIX
            }
        });
    }
    createSearchClient(options) {
        const { credential, endpoint, indexName } = this.#buildCredentials(options);
        this._searchClient = new _searchdocuments.SearchClient(endpoint, indexName, credential, {
            serviceVersion: this.#serviceApiVersion,
            userAgentOptions: {
                userAgentPrefix: options.userAgent ?? _AzureAISearchVectorStoreConfig.AzureAISearchVectorStoreConfig.DEFAULT_USER_AGENT_PREFIX
            }
        });
    }
    async #validateIndex(indexName) {
        if (this._indexClient && indexName && !await this.#indexExists(indexName)) {
            throw new Error(`Validation failed, index ${indexName} does not exist.`);
        }
    }
    /**
   * Create AI Search index document from embedding result.
   * @param node The node to create the index document from
   * @returns The mapped index document from the node
   */ #createIndexDocument(node) {
        _env.consoleLogger.log(`Mapping indexed document: ${node.id_}`);
        const metadata = (0, _utils.nodeToMetadata)(node, true, this.#chunkFieldKey, this.flatMetadata);
        return this.#indexMapping(node, metadata);
    }
    /**
   * Generate an OData filter string using supplied metadata filters.
   * @param metadataFilters
   * @returns
   */ #createOdataFilter(metadataFilters) {
        const odataFilter = [];
        for (const subfilter of metadataFilters.filters){
            // Join values with ' or ' to create an OR condition inside the any function
            const metadataMapping = this.#metadataToIndexFieldMap.get(subfilter.key);
            if (!metadataMapping) {
                throw new Error(`Metadata field '${subfilter.key}' is missing a mapping to an index field. Please provide an entry in 'filterableMetadataFieldKeys' for this vector store.`);
            }
            const indexField = metadataMapping[0];
            if (subfilter.operator === _types.FilterOperator.IN) {
                let valueStr;
                if (Array.isArray(subfilter.value)) {
                    valueStr = subfilter.value.map((value)=>typeof value === "string" ? `t eq '${value}'` : `t eq ${value}`).join(" or ");
                } else {
                    valueStr = typeof subfilter.value === "string" ? `t eq '${subfilter.value}'` : `t eq ${subfilter.value}`;
                }
                odataFilter.push(`${indexField}/any(t: ${valueStr})`);
            } else if (subfilter.operator === _types.FilterOperator.EQ) {
                const escapedValue = typeof subfilter.value === "string" ? subfilter.value.replace(/'/g, "''") : subfilter.value;
                odataFilter.push(`${indexField} eq '${escapedValue}'`);
            } else {
                throw new Error(`Unsupported filter operator ${subfilter.operator}. Supported operators are 'IN' and 'EQ'`);
            }
        }
        let odataExpr = "";
        if (metadataFilters.condition === _types.FilterCondition.AND) {
            odataExpr = odataFilter.join(" and ");
        } else if (metadataFilters.condition === _types.FilterCondition.OR) {
            odataExpr = odataFilter.join(" or ");
        } else {
            throw new Error(`Unsupported filter condition ${metadataFilters.condition}. Supported conditions are 'AND' and 'OR'`);
        }
        _env.consoleLogger.log(`OData filter: ${odataExpr}`);
        return odataExpr;
    }
    #createNodeFromResult(result, fieldMapping) {
        const { document } = result;
        const metadataStr = document[fieldMapping["metadata"]];
        const metadata = metadataStr ? JSON.parse(metadataStr) : {};
        try {
            const node = (0, _utils.metadataDictToNode)(metadata);
            node.setContent(document[fieldMapping["chunk"]]);
            node.embedding = document[fieldMapping["embedding"]];
            return node;
        } catch (error) {
            throw new Error(`Failed to create node from search result`);
        }
    }
    #buildFilterString(fieldMapping, nodeIds, filters) {
        let filterStr = "";
        if (nodeIds && nodeIds.length > 0) {
            filterStr = nodeIds.map((nodeId)=>`${fieldMapping["id"]} eq '${nodeId}'`).join(" or ");
        }
        if (filters) {
            const metadataFilter = this.#createOdataFilter(filters);
            if (filterStr) {
                filterStr = `(${filterStr}) or (${metadataFilter})`;
            } else {
                filterStr = metadataFilter;
            }
        }
        return filterStr;
    }
    #processBatchResults(batchNodes, nodes, batchSize, limit) {
        if (batchNodes.length === 0) {
            return [
                nodes,
                false
            ];
        }
        nodes = [
            ...nodes,
            ...batchNodes
        ];
        // If we've hit the requested limit, stop
        if (limit && nodes.length >= limit) {
            return [
                nodes.slice(0, limit),
                false
            ];
        }
        // If we got fewer results than batch size, we've hit the end
        if (batchNodes.length < batchSize) {
            return [
                nodes,
                false
            ];
        }
        return [
            nodes,
            true
        ];
    }
    // public
    /**
   * Get search client
   * @returns Azure AI Search client. See {@link SearchClient}
   */ client() {
        return this._searchClient;
    }
    /**
   * Get index client
   * @returns Azure AI Search index client. See {@link SearchIndexClient}
   */ indexClient() {
        return this._indexClient;
    }
    /**
   * Add nodes to index associated with the configured search client.
   * @param nodes List of nodes with embeddings to add to the index
   * @returns List of node IDs that were added to the index
   */ async add(nodes) {
        if (!this._searchClient) {
            throw new Error("Async Search client not initialized");
        }
        if (!nodes || nodes.length === 0) {
            return [];
        }
        if (nodes.length > 0) {
            if (this.#indexManagement === "CreateIfNotExists" && this.#indexName) {
                await this.#createIndexIfNotExists(this.#indexName);
            }
            if (this.#indexManagement === "ValidateIndex") {
                await this.#validateIndex(this.#indexName);
            }
        }
        const accumulator = new _searchdocuments.IndexDocumentsBatch();
        let documents = [];
        const ids = [];
        let accumulatedSize = 0;
        const maxSize = _AzureAISearchVectorStoreConfig.AzureAISearchVectorStoreConfig.DEFAULT_MAX_MB_SIZE;
        const maxDocs = _AzureAISearchVectorStoreConfig.AzureAISearchVectorStoreConfig.DEFAULT_MAX_BATCH_SIZE;
        for (const node of nodes){
            _env.consoleLogger.log(`Processing embedding: ${node.id_}`);
            const indexDocument = this.#createIndexDocument(node);
            const documentSize = JSON.stringify(indexDocument).length; // in bytes
            documents.push(indexDocument);
            accumulatedSize += documentSize;
            accumulator.upload(documents);
            if (documents.length >= maxDocs || accumulatedSize >= maxSize) {
                _env.consoleLogger.log(`Uploading batch of size ${documents.length}, current progress ${ids.length} of ${nodes.length}, accumulated size ${(accumulatedSize / (1024 * 1024)).toFixed(2)} MB`);
                await this._searchClient.indexDocuments(accumulator);
                documents = [];
                accumulatedSize = 0;
            }
            ids.push(node.id_);
        }
        if (documents.length > 0) {
            _env.consoleLogger.log(`Uploading remaining batch of size ${documents.length}, current progress ${ids.length} of ${nodes.length}, accumulated size ${(accumulatedSize / (1024 * 1024)).toFixed(2)} MB`);
            await this._searchClient.indexDocuments(accumulator);
        }
        return ids;
    }
    /**
   * Delete documents from the AI Search Index with docIdFieldKey (doc_id) field equal to refDocId.
   * @param refDocId The reference document ID to delete from the index
   */ async delete(refDocId) {
        // Check if index exists
        if (!await this.#indexExists(this.#indexName)) {
            return;
        }
        if (!this._searchClient) {
            throw new Error("searchClient is not initialized");
        }
        // Define filter and batch size
        const filterExpr = `${this.#fieldMapping["doc_id"]} eq '${refDocId}'`;
        const batchSize = 1000;
        while(true){
            // Search for documents to delete
            _env.consoleLogger.log(`Searching with filter ${filterExpr}`);
            const searchResults = await this._searchClient.search("*", {
                filter: filterExpr,
                top: batchSize
            });
            // Collect document IDs to delete
            const docsToDelete = [];
            for await (const result of searchResults.results){
                const { document } = result;
                docsToDelete.push(document);
            }
            // Delete documents if found
            if (docsToDelete.length > 0) {
                _env.consoleLogger.log(`Deleting ${docsToDelete.length} documents`);
                await this._searchClient.deleteDocuments(docsToDelete);
            } else {
                _env.consoleLogger.log("No documents found to delete");
                break;
            }
        }
    }
    /**
   * Get nodes asynchronously from the Azure AI Search index.
   * @param nodeIds List of node IDs to retrieve from the index
   * @param filters Metadata filters to apply to the search
   * @param limit Maximum number of nodes to retrieve
   * @returns List of nodes retrieved from the index
   */ async getNodes(nodeIds, filters, limit) {
        if (!this._searchClient) {
            throw new Error("SearchClient not initialized");
        }
        const filterStr = this.#buildFilterString(this.#fieldMapping, nodeIds, filters);
        const nodes = [];
        const batchSize = 1000; // Azure Search batch size limit
        while(true){
            try {
                const searchRequest = createSearchRequest(this.#fieldMapping, filterStr, batchSize, nodes.length);
                const results = await this._searchClient.search("*", searchRequest);
                const batchNodes = [];
                for await (const result of results.results){
                    batchNodes.push(this.#createNodeFromResult(result, this.#fieldMapping));
                }
                const [updatedNodes, continueFetching] = this.#processBatchResults(batchNodes, nodes, batchSize, limit);
                nodes.push(...updatedNodes);
                if (!continueFetching) {
                    break;
                }
            } catch (error) {
                throw new Error(`Failed to get nodes from Azure AI Search: ${error}`);
            }
        }
        return nodes;
    }
    async query(query) {
        let odataFilter;
        if (query.filters) {
            odataFilter = this.#createOdataFilter(query.filters);
            _env.consoleLogger.log(`Querying with OData filter: ${odataFilter}`);
        }
        _env.consoleLogger.log({
            query
        });
        // Define base AzureQueryResultSearch object based on query mode
        let azureQueryResultSearch = new _AzureQueryResultSearch.AzureQueryResultSearchDefault(query, this.#fieldMapping, odataFilter, this._searchClient);
        switch(query.mode){
            case _types.VectorStoreQueryMode.SPARSE:
                azureQueryResultSearch = new _AzureQueryResultSearch.AzureQueryResultSearchSparse(query, this.#fieldMapping, odataFilter, this._searchClient);
                break;
            case _types.VectorStoreQueryMode.HYBRID:
                azureQueryResultSearch = new _AzureQueryResultSearch.AzureQueryResultSearchHybrid(query, this.#fieldMapping, odataFilter, this._searchClient);
                break;
            case _types.VectorStoreQueryMode.SEMANTIC_HYBRID:
                azureQueryResultSearch = new _AzureQueryResultSearch.AzureQueryResultSearchSemanticHybrid(query, this.#fieldMapping, odataFilter, this._searchClient);
                break;
        }
        // Execute the search and return the result
        return await azureQueryResultSearch.search();
    }
}
