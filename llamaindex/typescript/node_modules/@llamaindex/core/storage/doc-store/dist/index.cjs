Object.defineProperty(exports, '__esModule', { value: true });

var env = require('@llamaindex/env');
var index_cjs = require('../../../global/dist/index.cjs');
var index_cjs$1 = require('../../../schema/dist/index.cjs');

const TYPE_KEY = "__type__";
const DATA_KEY = "__data__";
const jsonSerializer = {
    toPersistence (data) {
        return JSON.stringify(data);
    },
    fromPersistence (data) {
        return JSON.parse(data);
    }
};
const noneSerializer = {
    toPersistence (data) {
        return data;
    },
    fromPersistence (data) {
        return data;
    }
};
function isValidDocJson(docJson) {
    return typeof docJson === "object" && docJson !== null && docJson[TYPE_KEY] !== undefined && docJson[DATA_KEY] !== undefined;
}
function docToJson(doc, serializer) {
    return {
        [DATA_KEY]: serializer.toPersistence(doc.toJSON()),
        [TYPE_KEY]: doc.type
    };
}
function jsonToDoc(docDict, serializer) {
    const docType = docDict[TYPE_KEY];
    // fixme: zod type check this
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const dataDict = serializer.fromPersistence(docDict[DATA_KEY]);
    let doc;
    if (docType === index_cjs$1.ObjectType.DOCUMENT) {
        doc = new index_cjs$1.Document({
            text: dataDict.text,
            id_: dataDict.id_,
            embedding: dataDict.embedding,
            hash: dataDict.hash,
            metadata: dataDict.metadata
        });
    } else if (docType === index_cjs$1.ObjectType.TEXT) {
        doc = new index_cjs$1.TextNode({
            text: dataDict.text,
            id_: dataDict.id_,
            hash: dataDict.hash,
            metadata: dataDict.metadata,
            relationships: dataDict.relationships
        });
    } else {
        throw new Error(`Unknown doc type: ${docType}`);
    }
    return doc;
}
const DEFAULT_PERSIST_PATH = env.path.join(index_cjs.DEFAULT_PERSIST_DIR, index_cjs.DEFAULT_DOC_STORE_PERSIST_FILENAME);
class BaseDocumentStore {
    // Save/load
    persist(persistPath = DEFAULT_PERSIST_PATH) {
    // Persist the docstore to a file.
    }
    // Nodes
    getNodes(nodeIds, raiseError = true) {
        return Promise.all(nodeIds.map((nodeId)=>this.getNode(nodeId, raiseError)));
    }
    async getNode(nodeId, raiseError = true) {
        const doc = await this.getDocument(nodeId, raiseError);
        if (!(doc instanceof index_cjs$1.BaseNode)) {
            throw new Error(`Document ${nodeId} is not a Node.`);
        }
        return doc;
    }
    async getNodeDict(nodeIdDict) {
        const result = {};
        for(const index in nodeIdDict){
            result[index] = await this.getNode(nodeIdDict[index]);
        }
        return result;
    }
    constructor(){
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.serializer = jsonSerializer;
    }
}

exports.BaseDocumentStore = BaseDocumentStore;
exports.docToJson = docToJson;
exports.isValidDocJson = isValidDocJson;
exports.jsonSerializer = jsonSerializer;
exports.jsonToDoc = jsonToDoc;
exports.noneSerializer = noneSerializer;
