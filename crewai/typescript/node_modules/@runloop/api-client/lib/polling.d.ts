export interface PollingOptions<T> {
    /** Initial delay before starting polling (in milliseconds) */
    initialDelayMs?: number;
    /** Delay between subsequent polling attempts (in milliseconds) */
    pollingIntervalMs?: number;
    /** Maximum number of polling attempts before throwing an error */
    maxAttempts?: number;
    /** Optional timeout for the entire polling operation (in milliseconds) */
    timeoutMs?: number;
    /**
     * Condition to check if polling should stop
     * Return true when the condition is met and polling should stop
     */
    shouldStop?: (result: T) => boolean;
    /** Optional callback for each polling attempt */
    onPollingAttempt?: (attempt: number, result: T) => void;
}
export declare class PollingTimeoutError extends Error {
    lastResult: unknown;
    constructor(message: string, lastResult: unknown);
}
export declare class MaxAttemptsExceededError extends Error {
    lastResult: unknown;
    constructor(message: string, lastResult: unknown);
}
/**
 * Generic polling function that handles polling logic with configurable options
 * @param initialRequest Function that performs the initial API request
 * @param pollingRequest Function that performs subsequent polling requests
 * @param options Polling configuration options
 * @returns The final result of type T
 */
export declare function poll<T>(initialRequest: () => Promise<T>, pollingRequest: () => Promise<T>, options?: PollingOptions<T>): Promise<T>;
//# sourceMappingURL=polling.d.ts.map